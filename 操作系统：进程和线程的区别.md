# 1 进程和线程的区别

**下面细说背景**：
CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

**一个最最基础的事实：时间切片**：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。

**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的**程序上下文**。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是**保存程序上下文**，因为这个是下次他被CPU临幸的运行环境，必须保存。

**串联起来的事实**：前面讲过的，在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：

先加载程序A的上下文——然后开始执行A——保存程序A的上下文——调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文……

进程和线程就是这样的背景出来的，**两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。**

**进程就是包括上下文切换的、程序执行时间的总和 = CPU加载上下文+CPU执行+CPU保存上下文**

**线程是什么呢？**

进程的颗粒度太大，每次都要有上下文的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU ——>CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段——>最后CPU保存A的上下文。

这里三个线程a，b，c的执行是共享了A的上下文的，CPU在执行的时候没有进行上下文切换的。这**里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。**



## 1.1 小结

**进程就是包括上下文切换的、程序执行时间的总和 = CPU加载上下文+CPU执行+CPU保存上下文**。

**线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。**

**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**

## 1.2 补充

* 线程必须在进程下行进，且之存在于进程的概念之中。

* 一个进程可以包含多个线程

* 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘），但是，还是有办法的

* 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

* 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）

* **进程间不会相互影响，一个线程挂掉将导致整个进程挂掉**（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）

* **进程可以拓展到多机，线程最多拓展在多核**（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）

* 进程使用的**内存地址可以上锁**，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－**"互斥锁"**

* 进程使用的**内存地址可以限定使用量**（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－**“信号量”**。上面的互斥锁只是信号量等于1的特殊情况。

# 2 线程间的同步方式

同步，分为两种情况：

* 同步共享资源，各种锁机制、CAS等  https://www.cnblogs.com/XHJT/p/3897440.html
* 同步多个任务的执行，CountDownLatch    https://blog.csdn.net/zbc1090549839/article/details/53464902

## 2.1 同步共享资源

对前面链接中的内容进行解析。







## 2.2 同步多线程

对前面链接中的内容进行解析。







# 3 进程间通信方式

进程和线程（通信方式）、调度算法（6种）https://blog.csdn.net/Zhxin606a/article/details/88540399

## 3.1 共享内存

最有用的进程间通信方式。

它使得多个进程可以访问同一块内存空间， 不同进程可以及时看到对方进程中对共享内存中数据的更新。

这种方式需要依靠某种同步操作， 如互斥锁和信号量等。

## 3.2 消息队列

“消息队列” 是在消息的传输过程中保存消息的容器。

具有写权限的进程可以按照一定得规则向消息队列中添加新信息；

对消息队列有读权限的进程则可以从消息队列中读取信息。

## 3.3 信号

信号是一种比较复杂的通信方式， 用于通知接收进程某个事件已经发生。

## 3.4 信号量

**信号量是一个计数器， 可以用来控制多个进程对共享资源的访问。**

它常作为一种锁机制， 防止某进程正在访问共享资源时， 其他进程也访问该资源。

因此， 主要作为进程间以及同一进程内不同线程之间的同步手段。

## 3.5 套接字（socket）

这是一种更为一般得进程间通信机制， 它还可用于网络中不同机器之间的进程间通信， 应用非常广泛。

## 3.6 普通管道

**普通管道是一种半双工的通信方式**， 数据只能单向流动， 而且只能在具有父子关系的进程间使用。

单工：只能反向通信，比如，BB机，只具有接收消息的功能

半双工：同一时刻，通讯通道中只会存在一方的消息，比如，对讲机

全双工：双方可以在任意时刻先对方发送消息，且对方都能有效收到消息，比如，现在的电话

## 3.7 有名管道

有名管道也是半双工的通信方式， 但是它允许无亲缘关系进程间的通信。



# 4 线程的调度方式

一般情况下的线程调度方式分为两种，具体的是那种取决于线程调度实现及实现中的线程调度算法。

**抢占式调度：（由系统决定时间切片）**

指的是每条线程执行的时间、线程的切换都由系统控制。系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。**在这种机制下，一个线程的堵塞不会导致整个进程堵塞。**

**协同式调度：（线程间相互协同串行执行）**

指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。

## 4.1 Java的线程掉调度方式

java的线程调度策略取决于JVM的实现，JVM规范中规定，每个线程都有优先级，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，**可能**是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。

**Java使用的线程调度是抢占式调度**，在JVM中体现为，让可运行池中优先级高的线程拥有CPU使用权，如果可运行池中线程优先级一样则随机选择线程，但要注意的是**实际上一个绝对时间点只有一个线程在运行**（这里是相对于单核CPU来说，如果机器是多核CPU，一个绝对时间点还是可能多个线程同时运行的），直到此线程进入非可运行状态或另一个具有更高优先级的线程进入可运行线程池，JVM才会使之让出CPU的使用权，更高优先级的线程抢占了优先级低的线程的CPU。

**Java程序中，什么情况下当前线程的时间切片会被当前线程主动放弃呢（主动放弃时间切片就是主动放弃CPU的使用权）?**

1. 线程内主动调用某种方法，让出CPU的使用权（只不过是放弃本轮的时间切片使用），比如，调用yield()方法。该方法并不能保证当前线程立刻停止执行，只是让Java重新进行一次时间切片的分配，当前线程优先级价高，必然还是会继续执行，当前线程优先级较低，yield()就会让其他的优先级较高的线程“提前”执行起来。

   

   比如，主线程的优先级肯定是最高的。主线程和自己new出来的线程（暂且成为“子线程”）同时打印信息，子线程中调用yield()方法，触发一次JVM时间片分配，主线程中的打印频率更高，但是，子线程的打印也还是会有。说明：JVM确实会给优先级更高的线程分配更多的时间片段，但是，优先级较低的线程也还是**一定会有**时间片的，尽管少一点。

   （yield wait sleep的区别：https://blog.csdn.net/gonelikefly/article/details/77895864）

2.  当前线程遇到IO阻塞，会主动放弃本轮的时间切片。（底层已自动实现）

3. Thread.start()方法执行完毕。

具体的例子见：Java线程调度方式：https://blog.csdn.net/weixin_34362875/article/details/93318053

