# 1 摘要

**为什么要索引**？

没有索引的话，查找时间时O(n)



**各种数据结构的索引优劣**？

（索引是建立在排序的基础上的）

链表，初步排序后，通过链表数据结构的搜索时间大大缩短，但还是O(n)。

数组，可使用二分法了，时间是O(logN)，但是，增删数据很慢。

平衡二叉树（也就是，红黑树），二叉树的遍历和深度机器相关，平衡二叉树的时间是O(log2N)，很不错，但是适应不了索引极大的情况，因为，物理实现其实是数组，频繁IO时间仍然很长。红黑树（平衡二叉树）结构，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。

B树，充分利用了磁盘预读功能而**创造**的一种数据结构。**B树的每个节点可以存储多个关键字**，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，**树的深度就会非常的小**。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。

B+树，B树的变种。B树：有序数组+平衡多叉树；B+树：有序数组**链表**+平衡多叉树；B+树的**关键字全部存放在叶子节点**中，**非叶子节点用来做索引**，而叶子节点中有一个指针指向一下个叶子节点（链表）。数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。



总结一下，B+树成为主流大型数据库索引的原因：

* 带顺序访问指针的B+Tree

B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。

这样做是为了提高区间效率，例如查询key为从18到49的所有数据记录，当找到18后，只要顺着节点和指针顺序遍历就可以以此向访问到所有数据节点，极大提高了区间查询效率。

* 大大减少磁盘I/O读取

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点需要一次I/O就可以完全载入。





## 1.1 常识补充

mysql的B+树索引 查找使用了二分查找，redis 跳表也使用了二分查找法，kafka查询消息日志也使用了二分查找法，二分查找法时间复杂度O(logn);

参考：**redis的索引底层的 跳表原理 实现** [聊聊Mysql索引和redis跳表 ---redis的跳表原理 时间复杂度O(logn)(阿里)](https://www.cnblogs.com/aspirant/p/11475295.html)

参考：[kafka如何实现高并发存储-如何找到一条需要消费的数据(阿里)](https://www.cnblogs.com/aspirant/p/11481332.html)

参考：二分查找法：[各种排序算法的时间复杂度和空间复杂度(阿里)](https://www.cnblogs.com/aspirant/p/11470971.html)

在MySQL中，主要有四种类型的索引，分别为：

* B-Tree索引，包括B+ Tree；B树：有序数组+平衡多叉树； 
  B+树：有序数组**链表**+平衡多叉树；
* Hash索引，
* Fulltext索引(\**MyISAM 表\**)
* R-Tree索引，本文讲的是B-Tree索引。

Mysql可以配置不同的**存储引擎**，各个存储引擎的默认索引是不同的：

(a) Inodb存储引擎 默认是 B+Tree索引；**B+Tree是mysql使用最频繁的一个索引数据结构，是Inodb和Myisam存储引擎模式的索引类型**。相对Hash索引，B+Tree在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以它更受欢迎。毕竟不可能只对数据库进行单条记录的操作。

(b) MyISAM 存储引擎 默认是Fulltext索引；

(c)Memory 存储引擎 默认 Hash索引；mysql中，只**有Memory(Memory表只存在内存中，断电会消失，适用于临时表)存储引擎显示支持Hash索引，是Memory表的默认索引类型**，尽管Memory表也可以使用B+Tree索引。Hash索引把数据以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为hash结构，每个键只对应一个值，而且是散列的方式分布。所以它并不支持范围查找和排序等功能。



# 2 各种数据结构作为索引的利弊分析

数据库中的索引（Index）是帮助数据库高效获取数据的数据结构。索引是在基于数据库表创建的，它包含一个表中某些列的值以及相应的条目对应的地址，并且把这些值存储在一个数据结构中。最常见的就是使用哈希表、B+树作为索引。

一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

## 2.1 不使用索引直接搜索

举个例子来说，假设我们有一个数据库表Employee，这个表分别有三个字段：name，age，address。假设表中有1000条记录。

假如没有使用索引，当我们查询名为“Jesus”的雇员的时候，即调用：

```
select name,age,address from Employee where name = 'Jesus';
```

此时数据库不得不在Employee表中对这1000条记录一条一条的进行判断name字段是否为“Jesus”。这也就是所谓的全表扫描。

而当我们在Employee表上的name字段上创建索引时，当我们查询名为“Jesus”的雇员时，会通过索引查找去查询名为“Jesus”的雇员，因为该索引已经按照字母顺序排列，因此要查找名为“Jesus”的记录时会快很多，因为名字首字母为“J”的雇员都是排列在一起的。通过该索引，能获取到表中对应的记录。

那么该使用哪种数据结果作为索引的数据结构呢？

## 2.2  使用链表作为索引数据结构

假设索引（索引是一种数据结构）是链表结构。每个节点存储的是关键字字段（这个例子中对应的是name属性）以及该关键字字段在数据库表的对应的记录的地址。而这些节点是根据name属性排序的（即根据字母顺序排序）。因此，当我们执行上面说的查找名为“Jesus”的sql语句时，数据库会通过该索引来查询，因为该链表是有序排列的，在我们找到第一个name属性为“Jesus”的节点后，继续往后找，当遇到name属性不为“Jesus”的节点时，就无需再往后查找了，因为节点是根据name属性有序排列的啊。假设第一个name=“Jesus”的节点是第499个节点，最后一个name=“Jesus”的节点是第500个节点，那么只需要遍历501个节点就可以了。当发现第501个节点的name字段不为“Jesus”，后面的499个节点也就无需遍历了。通过索引，我们就找到了name为“Jesus”的节点，而通过该节点的另一个属性（关键字字段在数据库表的对应的记录的地址），我们就能获取到Employee表中满足条件name=“Jesus”的记录了。

通过使用索引，查询判断的次数就从1000次缩小到了501次了。起到了加速了查询效率。但实际上数据库中索引的结构，并不是链表结构，因为效率太低了。 

## 2.3 数组作为索引的数据结构

我们知道链表的查询效率是O(n)。就像上面的例子，遍历了501次才找到第一条符合条件的记录，这是很低效的。而我们知道，数组+二分查找的效率是O(lgn)，但是数组的插入元素以及删除元素的效率很低，因此使用数组做为索引结构并不合适。

另外，在选择数据库索引的结构的时候，要考虑到另一个问题。索引是存在于磁盘中，当索引非常大的时候，达到几个G的时候，无法一次加载到内存中。

考虑到上面两个因素（方便增删数据和分批加载到内存），数据库中索引使用的是树形结构。

## 2.4 树作为索引的数据结构

可参考[从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)

搜索树有很多种，同一种结果有很多不同的叫法：

* 二叉查找树

又分为常见的三种：

二叉查找树：

平衡二叉树：任意一个的节点的子节点的高度差的<=1，这种定义是为了保证经过变换，都能保证的搜索树的最大深度，从而保证搜索时的时间复杂度

红黑树：

* B树：B-tree，有些人叫它B减树，并不是二叉树，真正的学名是“多路搜索树”
* B+树：基于B树进行一些优化
* B*树：不清楚……

### 2.4.1 平衡二叉树作为索引数据结构

我们知道，二叉树的查找的时间复杂度是O(log2N)，其查找效率与深度有关，而普通的二叉树可能由于内部节点排列问题退化成链表，这样查找效率就会很低。因此平衡二叉树是更好的选择，因为它保持平衡，即通过旋转调整结构保持最小的深度。其查找的时间复杂度也是O(log2N)。

但实际上，数据库中索引的结构也并非AVL树或更优秀的红黑树，尽管它的查询的时间复杂度很低。

那为什么平衡二叉树不适合？**主要是因为IO问题：**

索引是存在于索引文件中，是存在于磁盘中的。因为索引通常是很大的，**因此无法一次将全部索引加载到内存当中，因此每次只能从磁盘中读取一个磁盘页（1个page，4k或者8k，不同操作系统，大小稍有不同）的数据到内存中。**而这个磁盘的读取的速度较内存中的读取速度而言是差了好几个级别。

注意，我们说的平衡二叉树结构，指的是逻辑结构上的平衡二叉树，但平衡二叉树的物理实现是数组。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。

而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构。

### 2.4.2 B树作为索引的数据结构

平衡二叉树没能充分利用磁盘预读功能，而B树是为了充分利用**磁盘预读功能**来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。

局部性原理与磁盘预读：

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： 

```
当一个数据被用到时，其附近的数据也通常会马上被使用。 
程序运行期间所需要的数据通常比较集中。 
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序（比如，构造一种充分利用局部性的索引数据结构）来说，预读可以提高I/O效率。
```

红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据（也就是，一个page）进行查找。

如下图所示，即是一棵B树，一棵关键字为“英语中辅音字母”的B树，现在要从树中查找字母R。亮灰色的结点为查找字母R时要检查的结点，经过几点就是读了几个page，就是进行了几次IO操作：

![字母查找_B树示意图](.\resources\字母查找_B树示意图.jpg)

**从节点中可以看出，一个节点内含有N个属性值时，就注定有N+1个子节点，这主要是方便进行二分查找。所有的叶结点都处于相同的深度**

B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。

### 2.4.3 B+树作为索引数据结构

MySQL中也是使用B+树作为索引。它是B树的变种，因此是基于B树来改进的。为什么B+树会比B树更加优秀呢？

B树：有序数组（并不Array的意思）+平衡多叉树；
B+树：有序数组（并不Array的意思）**链表**+平衡多叉树；

B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有指针指向一下个叶子节点，也就是说，**所有真实的字段值都只出现在最底层的叶子节点，上面的索引值都只是辅助二分查找用的并没有真正用到的字段值**。做这个优化的目的是为了提高区间访问（基于范围的查询sql）的性能。而正是这个特性决定了B+树更适合用来存储外部数据。

以上面的查找字母为例子，想要查找某个属性的值是M到Q之间的条目：

对于B树，在找到第一个符合条件的字母M后，访问完第一个关键字所在的块后，如果还没找到O、P或者Q，我们还要继续从头开始遍历这个B树，获取OPQ所在的块，直到遇到一个不符合条件的关键字。遍历的过程是比较复杂的。

相比之下，B+树的基于范围的查询简洁很多。由于叶子节点有指向下一个叶子节点的指针，因此从块“MN”到块"OPQ"的访问，通过块“MN”指向块"OPQ"的指针即可。从块“xxxx”到块“xxxx”也是通过一个指针即可。

```
数据库索引采用B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。
B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。
```

# 3 索引原理



## 3.1  索引原理

索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数。相似的例子还有：查字典，查火车车次，飞机航班等

**本质都是：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。**

数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到**搜索树**，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

##  3.2 磁盘IO与预读

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。

每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。

**因为存在局部性原理，为了利用局部性原理来优化计算机的IO性能，有了预读取的做法。**

## 3.3 B+树索引的数据结构

任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度（树的遍历复杂度和数的高度正相关）可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。

再回顾一下B+树的两个特点：

* 利用了IO的预读，一个节点存放多个索引，并且大小等于1个page
* 叶子节点采用顺序链表，便于对字段属性进行范围搜索

![索引原理B+树](.\resources\索引原理B+树.png)

如上图，是一颗b+树，关于b+树的定义可以参见[B+树](http://zh.wikipedia.org/wiki/B%2B树)，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。**非叶子节点不一定存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。**

### 3.3.1 select * from table where age=29;

假设上图是一个小区的人员统计表 的 年龄字段的索引，数字代表年龄大小，现在要找所有29岁的人，则要查找数据项29，使用sql语句:

```sql
select * from table where age=29;
```

那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用**二分查找确定**29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

sql一般是在操作人员下发create index后自动建立索引，建立恰当的非叶子节点的索引边界是十分重要的，一般要保证被查找的属性均匀分布。

### 3.3.2 B+树的性质

1. **索引字段要尽量的小**：

意思是，表的字段大小（下面，成为“数据项”）在表达清晰的情况下，能精简就精简，占用空间越少越好。比如，表示人的年龄，只需要0-200范围内的整数即可，用不到bigint。

通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 /数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，**如果数据项占的空间越小，数据项的数量越多，树的高度越低。**这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据项放到叶子节点而不是内层节点，一旦放到内层节点（也就是 非叶子节点，非叶子节点只放用于辅助二分查找的 数据项），磁盘块的数据项会大幅度下降，导致树增高。当单个节点内的数据项等于1时将会退化成线性表。

所以，对某一字段生成的索引，包含了两种：

* 不是真实存在的、仅用于辅助二分查找的属性值，放在内层节点
* 真实存在的属性值，放在叶子节点

2. **索引的最左匹配特性（即从左往右匹配）**：当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即**索引的最左匹配特性**。

## 3.4 全文索引（FULLTEXT）

**mysql的 myISAM搜索引擎默认的索引类型=全文索引（FULLTEXT）**。

MySQL从3.23.23版开始支持全文索引，**fulltext索引仅可用于 MyISAM 表**；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE  INDEX被添加。

### 3.4.1 全文索引最适用的场景

对文本字段上的创建普通的索引，只能加快对出现在字段内容最前面的字符串(也就是字段内容开头的字符)进行检索操作。如果字段里存放的是由几个、甚至是多个单词构成的较大段文字，普通索引就没什么作用了。因为，这种查询场景下的sql语句往往以LIKE %word%的形式出现，这对MySQL来说很复杂，如果需要处理的数据量很大，响应时间就会很长。这时，全文索引(full-text  index)可以大显身手的地方。在生成这种类型的索引时，MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。全文索引即可以随数据表一同创建，也可以等日后有必要时再使用下面这条命令添加： 

```sq
ALTER TABLE table_name ADD FULLTEXT(column1, column2) 
```

有了全文索引，就可以用SELECT查询命令去检索那些包含着一个或多个给定单词的数据记录了。下面是这类查询命令的基本语法：

```sql
SELECT * FROM table_name 
WHERE MATCH(column1, column2) AGAINST('word1', 'word2', 'word3');
# 上面这条命令将把column1和column2字段里有word1、word2和word3的数据记录全部查询出来。 
```

对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

参考：[Mysql索引详解及优化(key和index区别)](https://www.cnblogs.com/pcyy/p/7943759.html) 

## 3.5  索引使用注意事项

1. 不要滥用索引

* 索引提高查询速度，却会降低更新表的速度，因为更新表时，mysql不仅要更新数据，保存数据，还要更新索引，保存索引

* 索引会占用磁盘空间 

2. 索引不会包含含有NULL值的列

复合索引只要有一列含有NULL值,那么这一列对于此复合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL。 

3. MySQL查询只是用一个索引

如果where字句中使用了索引的话，那么order by中的列是不会使用索引的 

4. like

like '%aaa%'不会使用索引而like "aaa%"可以使用索引

5. 建立合适的索引：主键索引、唯一索引、普通索引、全文索引、组合索引

   * INDEX（普通索引）：ALTER TABLE 'table_name' ADD INDEX index_name('col')

   最基本的索引，没有任何限制 

   * UNIQUE（唯一索引）：ALTER TABLE 'table_name' ADD UNIQUE('col')

   **与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。** 

   * PRIMARY KEY（主键索引）：ALTER TABLE 'table_name' ADD PRIMARY KEY('col')

   是一种特殊的唯一索引，不允许有空值。 

   * FULLTEXT（全文索引）：ALTER TABLE 'table_name' ADD FULLTEXT('col')

   仅可用于MyISAM和InoDB，针对较大的数据，生成全文索引很耗时耗空间

   组合索引：ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')

   * 组合索引：为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，依次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1,col1col2,col1col2col3三个索引

[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)（超赞的文章，2011年写的文章，厉害……） 

[从B树、B+树、B*树谈到R 树](http://blog.csdn.net/v_JULY_v/article/details/6530142)(这篇文章作者也是好厉害，其博客访问量达千万) 

[浅谈算法和数据结构: 十 平衡查找树之B树](http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html)，而这篇博文里有B树和B+树插入元素的过程GIF图，超赞，有助于对B树和B+树的理解！

[一步步分析为什么B+树适合作为索引的结构](https://blog.csdn.net/weixin_30531261/article/details/79312676)

[MySQL索引原理以及查询优化](https://www.cnblogs.com/bypp/p/7755307.html)