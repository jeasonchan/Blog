# 1 前言
 深入解析Mysql 主从同步延迟原因及解决方案     https://www.cnblogs.com/cnmenglang/p/6393769.html

MySQL主从同步部署、主从原理及读写分离     https://blog.csdn.net/qq_15092079/article/details/81672920

# 2 mysql主从复制及延迟
MySQL的主从同步是一个很成熟的架构，优点为：

（1）在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;

（2）在从服务器从主服务器取“备份”文件，可避免备份期间影响主服务器服务;

（3）当主服务器出现问题时，可以切换到从服务器。

## 2.1 主从复制原理
**老版本**mysql的主从复制是单线程的操作，主库对所有DDL和 DML会产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率很高。根据去回来的binlog，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。

## 2.2 主从延迟产生原因
DML和DDL的**IO操作**是随机（不是SQL的执行顺序是随机的），不是顺序的，成本较高，甚至在binlog操作实施的过程中，slave上的查询可能会有事务锁，由于Slave_SQL_Running也是单线程的，所以单线程中的一个DDL或者DML卡住了，后续的DDL或者DML就不得不等待当前这个执行完才会继续执行，这就导致了延时。

同时还有别的原因，如果是一个很复杂的DML或者DDL操作，主库是可以多线程并发进行的，多线程处理速度本来就快，再加上，从库由于是通过一个单线程Slave_SQL_Running进行这些复杂的DML或者DDL操作，又比主库慢了很多。

**值得注意的是，**mysql-5.6.3已经支持了多线程的主从复制，原理和阿里奇数专家丁奇的实现类似，丁奇的是以表做多线程进行出从复制。Oracle使用的是以数据库(schema)为单位做多线程，不同的库可以使用不同的复制线程。

总结一下，两个主要原因：

1. 主库的DML和DDL很复杂，或者 TPS巨多时，超过了从库的线程处理能力，会增大主动延迟

2. 从库中执行的事务性查询可能会导致锁等待

## 2.3 解决方案
1、优化语句，能DDL和DML快速执行

2、优化部署方案、配置。
还有就是主库是写，对数据安全性较高，比如 sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也 可以设置为0来提高sql的执行效率。

减小slave_net_timeout，单位为秒 默认设置为 3600秒。参数含义：当slave想从主数据库读取log数据，能接收的网络连接超时。可减轻网络原因带来的主从延迟。

减小master-connect-retry单位为秒 默认设置为 60秒。参数含义：当重新建立主从连接时，如果连接建立失败，**间隔多久后重试**。可减轻网络原因带来的主从延迟。

使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器，只作为备份用（不执行查询，避免锁等待），不进行其他任何操作。

3、使用比主库更好的硬件设备作为slave。

## 2.4 如何定位、判断主从延迟
基于局域网的master/slave机制在通常情况下已经可以满足'实时'备份的要求了。如果延迟比较大，可先确认以下几个因素确定原因： 
1. 网络延迟
2. master负载(DML和DDL量大)
3. slave负载（DML和DDL量很大、查询量大）

判断主从延时，有两个指标：
1. Seconds_Behind_Master
2. mk-heartbeat

下面具体说下两者在实现功能的差别。

### 2.4.1 Seconds_Behind_Master
show slave status 命令输出的Seconds_Behind_Master参数的值来判断，是否有发生主从延时。

其值有这么几种：

NULL - 表示io_thread或是sql_thread有任何一个发生故障，也就是该线程的Running状态是No,而非Yes.

0 - 该值为零，是我们极为渴望看到的情况，**在主动网络良好的情况下**，0表示主从复制良好，可以认为lag不存在。

正值 - 表示主从已经出现延时，数字越大表示从库落后主库越多。

负值 - 几乎很少见，只是听一些资深的DBA说见过，其实，这是一个BUG值，该参数是不支持负值的，也就是不应该出现。

Seconds_Behind_Master是通过比较sql_thread执行的event的timestamp和io_thread复制好的 event的timestamp(简写为ts)进行比较，而得到的这么一个差值。sql_thread执行的时间戳肯定是**大于等于**io_thread复制的binlog里记录的时间戳的，因为，DML和DDL语句执行需要一定的时间。

我们都知道的relay-log和主库的bin-log里面的内容完全一 样，在记录sql语句的同时会记录当时的ts，所以比较参考的值来自于binlog，其实主从数据库的系统没有必要与NTP进行同步，也就是说无需保证主从时钟的 一致，因为比较的都是binlog里的时间戳时间差，io_thread的是刚取到的时间戳，sql_thread是刚执行完的时间戳。

但是，问题就出来了， 当主库I/O负载很大或是网络阻塞，io_thread**不能及时复制**binlog（没有中断，也在复制），而sql_thread一直都能跟上 io_thread的脚本，这时Seconds_Behind_Master的值是0，也就是我们从Seconds_Behind_Master参数可以暂且判断为无延时，但是，实际上不是。这也就是为什 么大家要批判用这个参数来监控数据库是否发生延时不准的原因，但是这个值并不是总是不准，如果当io_thread与主库网络很好的情况下，那么 该值也是很有价值的。之前，提到 Seconds_Behind_Master这个参数会有负值出现，我们已经知道该值是io_thread的最近跟新的ts与sql_thread执行到 的ts差值，前者始终是大于后者的，唯一的肯能就是某个event的ts发生了错误，比之前的小了，那么当这种情况发生时，负值出现就成为可能。

### 2.4.2 mk-heartbeat
mk-heartbeat，Maatkit万能工具包中的一个工具，被认为可以准确判断主从复制延时的方法。

mk-heartbeat的实现也是借助timestmp的比较实现的，它首先需要保证主从服务器的系统时间必须要保持一致，比如，通过与相同的一个NTP server同步时钟。

然后，在主库上创建一个heartbeat的表，里面至少有id与ts两个字段，id为server_id，ts就是当前的时间戳 now()，该结构也会被复制到从库上，表建好以后，会在主库上以后台进程的模式去执行一行更新操作的命令，定期去向表中的插入数据，这个周期默认为1 秒，同时从库也会在后台执行一个监控命令，与主库保持一致的周期去比较，复制过来记录的ts值与主库上的同一条ts值，差值为0表示无延时，差值越大表示 延时的秒数越多。我们都知道复制是异步的ts不肯完全一致，所以该工具允许半秒的差距，在这之内的差异都可忽略认为无延时。这个工具就是通过实打实的复制，巧妙的借用timestamp来检查延时，赞一个！

**说白了，已同一个时间为基准，比较同一个字段的最后更新时间，通过这个时间差来判断是否主从延迟。**
