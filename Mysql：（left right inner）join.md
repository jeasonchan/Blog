# 1 前言

参考文章：

sql之left join、right join、inner join的区别    https://www.cnblogs.com/pcjim/articles/799302.html

使用关系型数据库，大型的项目难免有分库分表的情况，尤其是字段名巨多的情况下，跨表联合查询几乎是必备项目了，很多情况下会使用join这个sql关键字。

接下来介绍一下，join1的使用法方法。

#  2 left inner rght join的区别
join是加入的意思，在进行select的时候经常使用，想表达的意思是，将某些表临时合并/看成（join）成一张表进行查询操作。

既然进行了"合并"表的操作，那就要区分进行表的合并时，是以那张表作为合并的基础？合并的时候是把数据的一行行记录对应上的？根据以上两个问题，就需要把join的操作分为三种：

* left join(左联接) 

以左表作为基础表，返回   左表的全部记录+从右表中根据联结字段查处来的记录  的 记录

* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录

以右表作为基础表，返回   右表的全部记录+从左表中根据联结字段查处来的记录  的 记录

* inner join(等值连接) 只返回两个表中联结字段相等的行

以链接字段作为查找条件，找到左右两表中联结字段相等的   左表中的记录+右表中的记录

介绍完了概念，用例子进行三种join的对比。

## 2.1 三种join的实例对比

举例两表的结构如下：

```
--------------------------------------------
表A记录如下：
aID　　　　　aNum
1　　　　　a20050111
2　　　　　a20050112
3　　　　　a20050113
4　　　　　a20050114
5　　　　　a20050115

表B记录如下:
bID　　　　　bName
1　　　　　2006032401
2　　　　　2006032402
3　　　　　2006032403
4　　　　　2006032404
8　　　　　2006032408

--------------------------------------------
```

### 2.1.1 left join

```sql
select * from A
left join B
on A.AaID = B.bID
```

先来分析一下sql语句，首先是个查询语句，被查寻的表是使用A left join B的表，联结的条件是 A.aID = B.bID。左联结，那就是以A表为基础，最后表A的记录肯定是都包含的，联结的过程是：以A.AaID的值为查询值，去查询B.AaID的属性，当A.AaID = B.bID为真时，B的该行记录符合联结的条件，加入到最终显示结果中。

因此，sql最后的结果如下：

```
aID　　　　　aNum　　　　　bID　　　　　bName
1　　　　　a20050111　　　　1　　　　　2006032401
2　　　　　a20050112　　　　2　　　　　2006032402
3　　　　　a20050113　　　　3　　　　　2006032403
4　　　　　a20050114　　　　4　　　　　2006032404
5　　　　　a20050115　　　　NULL　　　　　NULL
```
B表记录不足的地方均为NULL.

LEFT JOIN操作可用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，**即使在第二个（右边）表中并没有相符值的记录**。

语法格式：FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2

说明：

* table1, table2参数用于指定要将记录组合的表的名称。
* field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。
* compopr参数指定关系比较运算符："="， "<"， ">"， "<="， ">=" 或 "<>"。


### 2.1.2 right join

sql语句如下:

```sql
select * from A
right join B
on A.aID = B.bID
```

结果如下:

```
aID　　　　　aNum　　　　　bID　　　　　bName
1　　　　　a20050111　　　　1　　　　　2006032401
2　　　　　a20050112　　　　2　　　　　2006032402
3　　　　　a20050113　　　　3　　　　　2006032403
4　　　　　a20050114　　　　4　　　　　2006032404
NULL　　　　　NULL　　　　　8　　　　　2006032408
```

（所影响的行数为 5 行）
结果说明:
仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.


### 2.1.3 inner join

sql语句如下:

```sql
select * from A
inner join B
on A.aID = B.bID
```

结果如下:

```
aID　　　　　aNum　　　　　bID　　　　　bName
1　　　　　a20050111　　　　1　　　　　2006032401
2　　　　　a20050112　　　　2　　　　　2006032402
3　　　　　a20050113　　　　3　　　　　2006032403
4　　　　　a20050114　　　　4　　　　　2006032404
```

结果说明:

很明显,这里只显示出了 A.aID = B.bID的记录.这说明**inner join并不以谁为基础,它只显示符合条件的记录**.



# 3 对于join的思考

阿里等大公司很多情况下都不建议使用join，那join究竟有啥优劣？

## 3.1 为什么不用join？

在互联网项目中，程序的执行效率并不是摆在第一位的，摆在第一位的应该是程序的水平扩展性和可维护性。该不该用 JOIN，当然不能一刀切。引用《高性能 MySQL 》（本书虽然很好，但是是基于 MySQL 5.5 的，现在 MySQL 已经发展了不少，对于 JOIN 的优化也多了很多。）的6.3.3-分解关联查询 章节，总结得很全面：

**很多高性能的应用都**会对关联查询进行分解，有如下的优势：

1. 让缓存效率更高。如果某张表很少变化，那么基于该表的查询就可以重复利用查询缓存结果。
2. 将查询分解后，**执行单个查询**可以减少锁的竞争。
3. **在应用层做关联**，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
4. 查询本身效率也可能会有所提升。例如 **用 IN()代替关联查询**，可能比随机的关联更高效。
5. 减少冗余记录得查询。
6. 更进一步，这样做**相当于在应用中实现了哈希关联**，而不是使用 MySQL 得嵌套循环关联。某些场景哈希关联得效率要高很多。

## 3.2 join的好处
关联查询的好处就是在做分页的时候特别方便，一次性查询出想要的结果集和总记录数；如果在业务中做关联的话，中间会有很多判断和过滤，会导致总记录数与分页的需求不一致。

注：不使用关联查询做分页也不是不可以，解决的方法将分页功能交给前端，一次性查询，让前端分批显示就可以了，这种解决方案的前提是数据量不太，因为sql本身长度有限。