# 1 前言

参考文章：

sql之left join、right join、inner join的区别    https://www.cnblogs.com/pcjim/articles/799302.html

使用关系型数据库，大型的项目难免有分库分表的情况，尤其是字段名巨多的情况下，跨表联合查询几乎是必备项目了，很多情况下会使用join这个sql关键字。

接下来介绍一下，join1的使用法方法。

#  2 left inner rght join的区别
join是加入的意思，在进行select的时候经常使用，想表达的意思是，将某些表临时合并/看成（join）成一张表进行查询操作。

既然进行了"合并"表的操作，那就要区分进行表的合并时，是以那张表作为合并的基础？合并的时候是把数据的一行行记录对应上的？根据以上两个问题，就需要把join的操作分为三种：

* left join(左联接) 

以左表作为基础表，返回   左表的全部记录+从右表中根据联结字段查处来的记录  的 记录

* right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录

以右表作为基础表，返回   右表的全部记录+从左表中根据联结字段查处来的记录  的 记录

* inner join(等值连接) 只返回两个表中联结字段相等的行

以链接字段作为查找条件，找到左右两表中联结字段相等的   左表中的记录+右表中的记录

介绍完了概念，用例子进行三种join的对比。

## 2.1 三种join的实例对比

举例两表的结构如下：

```
--------------------------------------------
表A记录如下：
aID　　　　　aNum
1　　　　　a20050111
2　　　　　a20050112
3　　　　　a20050113
4　　　　　a20050114
5　　　　　a20050115

表B记录如下:
bID　　　　　bName
1　　　　　2006032401
2　　　　　2006032402
3　　　　　2006032403
4　　　　　2006032404
8　　　　　2006032408

--------------------------------------------
```

### 2.1.1 left join

```sql
select * from A
left join B
on A.AaID = B.bID
```

先来分析一下sql语句，首先是个查询语句，被查寻的表是使用A left join B的表，联结的条件是 A.aID = B.bID。左联结，那就是以A表为基础，最后表A的记录肯定是都包含的，联结的过程是：以A.AaID的值为查询值，去查询B.AaID的属性，当A.AaID = B.bID为真时，B的该行记录符合联结的条件，加入到最终显示结果中。

因此，sql最后的结果如下：

```
aID　　　　　aNum　　　　　bID　　　　　bName
1　　　　　a20050111　　　　1　　　　　2006032401
2　　　　　a20050112　　　　2　　　　　2006032402
3　　　　　a20050113　　　　3　　　　　2006032403
4　　　　　a20050114　　　　4　　　　　2006032404
5　　　　　a20050115　　　　NULL　　　　　NULL
```
B表记录不足的地方均为NULL.

LEFT JOIN操作可用于在任何的 FROM 子句中，组合来源表的记录。使用 LEFT JOIN 运算来创建一个左边外部联接。左边外部联接将包含了从第一个（左边）开始的两个表中的全部记录，**即使在第二个（右边）表中并没有相符值的记录**。

语法格式：FROM table1 LEFT JOIN table2 ON table1.field1 compopr table2.field2

说明：

* table1, table2参数用于指定要将记录组合的表的名称。
* field1, field2参数指定被联接的字段的名称。且这些字段必须有相同的数据类型及包含相同类型的数据，但它们不需要有相同的名称。
* compopr参数指定关系比较运算符："="， "<"， ">"， "<="， ">=" 或 "<>"。


### 2.1.2 right join

sql语句如下:

```sql
select * from A
right join B
on A.aID = B.bID
```

结果如下:

```
aID　　　　　aNum　　　　　bID　　　　　bName
1　　　　　a20050111　　　　1　　　　　2006032401
2　　　　　a20050112　　　　2　　　　　2006032402
3　　　　　a20050113　　　　3　　　　　2006032403
4　　　　　a20050114　　　　4　　　　　2006032404
NULL　　　　　NULL　　　　　8　　　　　2006032408
```

（所影响的行数为 5 行）
结果说明:
仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充.


### 2.1.3 inner join

sql语句如下:

```sql
select * from A
inner join B
on A.aID = B.bID
```

结果如下:

```
aID　　　　　aNum　　　　　bID　　　　　bName
1　　　　　a20050111　　　　1　　　　　2006032401
2　　　　　a20050112　　　　2　　　　　2006032402
3　　　　　a20050113　　　　3　　　　　2006032403
4　　　　　a20050114　　　　4　　　　　2006032404
```

结果说明:

很明显,这里只显示出了 A.aID = B.bID的记录.这说明**inner join并不以谁为基础,它只显示符合条件的记录**.



