# 1 七层网络结构

7层网络结构    https://blog.csdn.net/u010359398/article/details/82142449



# 2 传输层介绍

计算机网络协议(三)——UDP、TCP、Socket      https://blog.csdn.net/ghw15221836342/article/details/100531810?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3



OSI参考模型——传输层：TCP、UDP协议详解     https://blog.csdn.net/jeffleo/article/details/53967254?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1





## 2.1 TCP



## 2.2 UDP



## 2.3 Socket



# 3 相关面试题

## 3.1 浏览器输入URL后发什么什么

知乎回答  https://zhuanlan.zhihu.com/p/43369093

在题意不够明确、缺少情景和限定条件的情况下，没法直接作答。在计算机越来越复杂的今天，任何一个条件的变化与组合，都有可能产生千千万万种可能，打破常规。对题目本身而言，就会包括但不仅限于以下几种条件：

* 请求资源类型浏览器类型及版本
* 服务器类型及版本
* 网络协议类型及版本
* 网络链路状况经过哪些中间设备
* 局域网类型及标准物理媒介类型
* 运营商路线

如果请求的是静态资源，那么流量有可能到达 CDN（Content Delivery Network） 服务器；如果请求的是动态资源，那么情况更加复杂，流量可能依次经过代理/网关、Web 服务器、应用服务器、数据库。以下图 阿里云 SLB（Server Load Balancer，负载均衡）高可用部署示意图，它不同于传统的主备切换模式过于依赖单机处理能力，来自公网的请求通过上层交换机的 ECMP（Equal-cost multi-path routing，等价多路径路由）将流量转发给 LVS 集群（四层 SLB），对于 TCP/UDP 请求，LVS 集群直接转发给后端 ECS 集群，对于 HTTP 请求，则转发给 Tengine 集群（七层 SLB），由 Tengine 集群再转发给后端 ECS 集群，集群之间通过实现会话同步、健康检查等机制来保证高可用。

![阿里云负载均衡高可用部署示意图](https://pic1.zhimg.com/80/v2-e2050d15f42336e205122dd51a803230_720w.jpg)

随着业务规模的不断扩大，为了承载千万级甚至亿级流量及海量存储，对系统的多机房容灾、自由扩容的要求越来越高，系统还可能演进为下图的异地多活架构。与传统的灾备设计不同的是，多个数据中心同时对外提供服务，同时保证异地单元间数据库数据的一致性和完整性（CAP 理论）。整个系统架构分为流量层、应用层、数据层，利用 DNS 技术实现 GSLB（Global Server Load Balance，全局负载均衡），实现用户就近访问。如果某个地域的系统发生整体故障，则把所有流量请求切换到另一个地域，来满足异地容灾，这也类似于饿了么现阶段整体架构方案。

![阿里异地多活架构](https://pic3.zhimg.com/80/v2-c7887070dd99ffeb0ea8bf1eb7e58642_720w.jpg)

但是，静态资源不同于动态资源，考虑部署成本和流量成本后，静态资源一般是通过 CDN，利用中间服务器作缓存，如果没有命中缓存，再回源到 OSS（Object Storage Service，阿里云对象存储服务）或者私有服务器。

因此，现实世界的情况是千变万化的，很难想象一个 GET 请求甚至触发银行的转账操作，一切取决于后端实现。重新回到本文的主题，我们排除一切特殊条件，把问题简化一下，如果仅仅考虑：

* 一个 Chrome 浏览器
* 一台 Linux 服务器
* 发起 HTML 请求
* 不考虑任何缓存和优化机制
* 采用 HTTP/1.1 + TLS/1.2 + TCP 协议

这个过程如下：

3.1.1 DNS解析过程
首先，浏览器向本地 DNS 服务器发起请求，由于**本地 DNS 服务器没有缓存不能直接将域名转换为 IP 地址**，需要采用递归或者迭代查询的方式（图 3）依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器。一般本地 DNS 地址由 ISP（Internet Service Provider，互联网服务提供商）通过 DHCP 协议动态分配(局域网的话，一般是  xxx.xxx.xxx.1)，我们仍可以手动把它修改为公共 DNS，比如 Google 提供的 8.8.8.8，国内的 114.114.114.114，它们分布在不同的地理位置上，借助 Anycast 技术，将请求路由到离用户最近的 DNS 服务器上，公共DNS肯定是“分布式”部署的，不同地区访问离自己最近的那个DNS的节点分机。为了让 DNS 解析更加精确，客户端还需在请求包里带上自己的源 IP 地址，否则类似 GSLB 的 DNS 服务器不能够精准地匹配判断离用户最近的目标 IP 地址。

![DNS查询过程](https://pic1.zhimg.com/80/v2-b6cf454b2fc9144470f097c827a13ab0_720w.jpg)

3.1.2 HTTP请求过程
由于 HTTP 是基于更易于阅读的文本格式，除了在浏览器直接发起 HTTP 之外，你也可以用命令行 telnet 来与服务器指定端口建立 TCP 连接，按照协议规定的格式，来发送请求头和请求实体。HTTP请求是基于TCP应用协议，另外，如果想查看详细具体的封包内容，可以使用网络封包分析工具 Wireshark 或命令行 tcpdump，来捕获某一块网卡上的数据包。在上一步浏览器通过 DNS 解析拿到服务器 IP 地址后，浏览器再通过**系统调用** Socket 接口与服务器 443 端口（443端口是HTTPS服务器的默认端口号）进行通信，整个过程可以分解为：
1. 建立连接
2. 发送 HTTP 请求
3. 返回 HTTP 响应
4. 维持连接
5. 释放连接五个部分。

下图中，所示箭头有可能代表一个 TCP 报文段，也有可能代表一个完整的应用层报文，在实际传输过程中，会被组合为一个或分片为多个 TCP 报文段。

![HTTP请求完整过程](https://pic4.zhimg.com/80/v2-fd6349571db925bc12b9e0d320dd6f1b_720w.jpg)

接下来，分解HTTP的5个部分，详细讲解。

3.1.3 建立连接
1. 在连接建立之前，服务器必须做好接受连接的准备，通过调用 socket、bind、listen 和 accept 四个函数来完成绑定公网 IP、监听 443 端口和接受请求的任务。Java NIO 中，ServerSocketChannel  先 open，再bind，再accept，多路复用的实现略有不同。
2.客户端通过 socket 和 connect 两个函数来主动打开连接，给服务器发送带有 SYN 标志位的分组，随机生成一个初始序列号 x，以及附带 MSS（Maximum Segment Size，最大段大小）等额外信息。为了避免在网络层被 IP 协议分片使得出现丢失错误的概率增加，及达到最佳的传输效果，MSS 的值一般为以太网 MTU（Maximum Transmission Unit，最大传输单元）的值减去 IP 头部和 TCP 头部大小，等于 1460 字节。
3. 服务器必须确认收到客户端的分组，发送带有 SYN+ACK 标志位的分组，随机生成一个初始序列号 y，确认号为 x+1，以及附带 MSS 等额外信息。当一端收到另外一端的 MSS 值时，会根据两者的 MSS 取最小值来决定随后的 TCP 最大报文段大小。
4. 客户端确认收到服务器的分组，发送带有 ACK 标志位的分组，确认号为 y+1，从而建立 TCP 连接。
5. 如果客户端此前未与服务器建立会话，那么双方需要进行一次完整的 TLS 四次握手。客户端首先向服务器发送 Client Hello 报文，包含一个随机数、TLS 协议版本、按优先级排列的加密套件列表。
6. 服务器向客户端发送 Server Hello 报文，包含一个新的随机数、TLS 协议版本、经过选择后的一个加密套件。
7. 服务器向客户端发送 Certificate 报文，包含服务器 X.509 证书链，其中，第一个为主证书，中间证书按照顺序跟在主证书之后，而根 CA 证书通常内置在操作系统或浏览器中，无需服务器发送。
8. 如果密钥交换选择 DH 算法，服务器会向客户端发送 Server Key Exchange 报文，包含密钥交换所需的 DH 参数；如果密钥交换选择 RSA 算法，则跳过这一步。
9. 服务器向客户端发送 Server Hello Done 报文，表明已经发送完所有握手消息。
10. 客户端向服务器发送 Client Key Exchange 报文，如果密钥交换选择 RSA 算法，由客户端生成预主密钥，使用服务器证书中的公钥对其加密，包含在报文中，服务器只需使用自己的私钥解密就可以取出预主密钥；如果密钥交换选择 DH 算法，客户端会在报文中包含自己的 DH 参数，之后双方都根据 DH 算法计算出相同的预主密钥。需要注意的是，密钥交换的只是预主密钥，这个值还需进一步加工，结合客户端和服务器两个随机数种子，双方使用 PRF（pseudorandom function，伪随机函数）生成相同的主密钥。
11. 客户端向服务器发送 Change Cipher Spec 报文，表明已经生成主密钥，在随后的传输过程都使用这个主密钥对消息进行对称加密。
12. 客户端向服务器发送 Finished 报文，这条消息是经过加密的，因此在 Wireshark 中显示的是 Encrypted Handshake Message。如果服务器能解密出报文内容，则说明双方生成的主密钥是一致的。
13. 服务器向客户端发送 New Session Ticket 报文，而这个 Session Ticket 只有服务器才能解密，客户端把它保存下来，在以后的 TLS 重新握手过程中带上它进行快速会话恢复，减少往返延迟。
14. 服务器向客户端发送 Change Cipher Spec 报文，同样表明已经生成主密钥，在随后的传输过程都使用这个主密钥对消息进行对称加密。
15. 服务器向客户端发送 Finished 报文，如果客户端能解密出报文内容，则说明双方生成的主密钥是一致的。至此，完成所有握手协商。


3.1.4 发送 HTTP 请求
//



3.1.5 返回 HTTP 响应
//



3.1.6 维持连接
//

3.1.7 断开连接
//


3.1.8 浏览器解析过程
//


3.1.9 主流程
//



3.1.10 渲染流程
//


3.1.11 页面生命周期
//






