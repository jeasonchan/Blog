# 1 七层网络结构

7层网络结构    https://blog.csdn.net/u010359398/article/details/82142449



# 2 传输层介绍

计算机网络协议(三)——UDP、TCP、Socket      https://blog.csdn.net/ghw15221836342/article/details/100531810?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3



OSI参考模型——传输层：TCP、UDP协议详解     https://blog.csdn.net/jeffleo/article/details/53967254?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1





## 2.1 TCP



## 2.2 UDP



## 2.3 Socket



# 3 相关面试题

## 3.1 浏览器输入URL后发什么什么

知乎回答  https://zhuanlan.zhihu.com/p/43369093

在题意不够明确、缺少情景和限定条件的情况下，没法直接作答。在计算机越来越复杂的今天，任何一个条件的变化与组合，都有可能产生千千万万种可能，打破常规。对题目本身而言，就会包括但不仅限于以下几种条件：

* 请求资源类型浏览器类型及版本
* 服务器类型及版本
* 网络协议类型及版本
* 网络链路状况经过哪些中间设备
* 局域网类型及标准物理媒介类型
* 运营商路线

如果请求的是静态资源，那么流量有可能到达 CDN（Content Delivery Network） 服务器；如果请求的是动态资源，那么情况更加复杂，流量可能依次经过代理/网关、Web 服务器、应用服务器、数据库。以下图 阿里云 SLB（Server Load Balancer，负载均衡）高可用部署示意图，它不同于传统的主备切换模式过于依赖单机处理能力，来自公网的请求通过上层交换机的 ECMP（Equal-cost multi-path routing，等价多路径路由）将流量转发给 LVS 集群（四层 SLB），对于 TCP/UDP 请求，LVS 集群直接转发给后端 ECS 集群，对于 HTTP 请求，则转发给 Tengine 集群（七层 SLB），由 Tengine 集群再转发给后端 ECS 集群，集群之间通过实现会话同步、健康检查等机制来保证高可用。

![阿里云负载均衡高可用部署示意图](https://pic1.zhimg.com/80/v2-e2050d15f42336e205122dd51a803230_720w.jpg)

随着业务规模的不断扩大，为了承载千万级甚至亿级流量及海量存储，对系统的多机房容灾、自由扩容的要求越来越高，系统还可能演进为下图的异地多活架构。与传统的灾备设计不同的是，多个数据中心同时对外提供服务，同时保证异地单元间数据库数据的一致性和完整性（CAP 理论）。整个系统架构分为流量层、应用层、数据层，利用 DNS 技术实现 GSLB（Global Server Load Balance，全局负载均衡），实现用户就近访问。如果某个地域的系统发生整体故障，则把所有流量请求切换到另一个地域，来满足异地容灾，这也类似于饿了么现阶段整体架构方案。

![阿里异地多活架构](https://pic3.zhimg.com/80/v2-c7887070dd99ffeb0ea8bf1eb7e58642_720w.jpg)

但是，静态资源不同于动态资源，考虑部署成本和流量成本后，静态资源一般是通过 CDN，利用中间服务器作缓存，如果没有命中缓存，再回源到 OSS（Object Storage Service，阿里云对象存储服务）或者私有服务器。

因此，现实世界的情况是千变万化的，很难想象一个 GET 请求甚至触发银行的转账操作，一切取决于后端实现。重新回到本文的主题，我们排除一切特殊条件，把问题简化一下，如果仅仅考虑：

* 一个 Chrome 浏览器
* 一台 Linux 服务器
* 发起 HTML 请求
* 不考虑任何缓存和优化机制
* 采用 HTTP/1.1 + TLS/1.2 + TCP 协议

这个过程如下：

3.1.1 DNS解析过程
首先，浏览器向本地 DNS 服务器发起请求，由于**本地 DNS 服务器没有缓存不能直接将域名转换为 IP 地址**，需要采用递归或者迭代查询的方式（图 3）依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询请求，直至找到一个或一组 IP 地址，返回给浏览器。一般本地 DNS 地址由 ISP（Internet Service Provider，互联网服务提供商）通过 DHCP 协议动态分配(局域网的话，一般是  xxx.xxx.xxx.1)，我们仍可以手动把它修改为公共 DNS，比如 Google 提供的 8.8.8.8，国内的 114.114.114.114，它们分布在不同的地理位置上，借助 Anycast 技术，将请求路由到离用户最近的 DNS 服务器上，公共DNS肯定是“分布式”部署的，不同地区访问离自己最近的那个DNS的节点分机。为了让 DNS 解析更加精确，客户端还需在请求包里带上自己的源 IP 地址，否则类似 GSLB 的 DNS 服务器不能够精准地匹配判断离用户最近的目标 IP 地址。

![DNS查询过程](https://pic1.zhimg.com/80/v2-b6cf454b2fc9144470f097c827a13ab0_720w.jpg)

3.1.2 HTTP请求过程
由于 HTTP 是基于更易于阅读的文本格式，除了在浏览器直接发起 HTTP 之外，你也可以用命令行 telnet 来与服务器指定端口建立 TCP 连接，按照协议规定的格式，来发送请求头和请求实体。HTTP请求是基于TCP应用协议，另外，如果想查看详细具体的封包内容，可以使用网络封包分析工具 Wireshark 或命令行 tcpdump，来捕获某一块网卡上的数据包。在上一步浏览器通过 DNS 解析拿到服务器 IP 地址后，浏览器再通过**系统调用** Socket 接口与服务器 443 端口（443端口是HTTPS服务器的默认端口号）进行通信，整个过程可以分解为：
1. 建立连接
2. 发送 HTTP 请求
3. 返回 HTTP 响应
4. 维持连接
5. 释放连接五个部分。

下图中，所示箭头有可能代表一个 TCP 报文段，也有可能代表一个完整的应用层报文，在实际传输过程中，会被组合为一个或分片为多个 TCP 报文段。

![HTTP请求完整过程](https://pic4.zhimg.com/80/v2-fd6349571db925bc12b9e0d320dd6f1b_720w.jpg)

接下来，分解HTTP的5个部分，详细讲解。

3.1.3 建立连接
建立连接的过程，第一次访问该服务器和经常访问该服务器，过程略有不同。对于经常访问的站点，建立连接仅需要经典的三次握手。对于的首次访问的网站，建立连接需要完成完整的四次握手。断开连接时，一般需要四次挥手。

**三次握手**

1. 在连接建立之前，服务器必须做好接受连接的准备，通过调用 socket、bind、listen 和 accept 四个函数来完成绑定公网 IP、监听 443 端口和接受请求的任务。Java NIO 中，ServerSocketChannel  先 open，再bind，再accept，多路复用的实现略有不同。
2. 客户端通过 socket 和 connect 两个函数来主动打开连接，**给服务器发送带有 SYN 标志位的分组**。分组包含，随机生成的一个初始序列号 x，以及附带 MSS（Maximum Segment Size，最大段大小）等额外信息。为了避免在网络层被 IP 协议分片使得出现丢失错误的概率增加，及达到最佳的传输效果，MSS 的值一般为以太网 MTU（Maximum Transmission Unit，最大传输单元）的值减去 IP 头部和 TCP 头部大小，等于 1460 字节。
3. 服务器必须确认收到客户端的分组，**发送带有 SYN+ACK 标志位的分组**。分组包含，随机生成的一个初始序列号 y，确认号为 x+1，以及附带 MSS 等额外信息。当一端收到另外一端的 MSS 值时，会**根据两者的 MSS 取最小值来决定随后的 TCP 最大报文段大小。**
4. 客户端确认收到服务器的分组，发送带有 ACK 标志位的分组，确认号为 y+1，从而建立 TCP 连接。

**四次握手**
（第一次）
1. 如果客户端此前未与服务器建立会话，那么双方需要进行一次完整的 TLS 四次握手。客户端首先向服务器发送 Client Hello 报文，包含一个随机数、TLS 协议版本、按优先级排列的加密socket列表。

（第二次）
2. 服务器向客户端发送 Server Hello 报文，包含一个新的随机数、TLS 协议版本、经过选择后的一个加密socket。
3. 服务器向客户端发送 Certificate 报文，包含服务器 X.509 证书链，其中，第一个为主证书，中间证书按照顺序跟在主证书之后，而根 CA 证书通常内置在操作系统或浏览器中，无需服务器发送。
4. 如果密钥交换选择 DH 算法，服务器会向客户端发送 Server Key Exchange 报文，包含密钥交换所需的 DH 参数；如果密钥交换选择 RSA 算法，则跳过这一步。
5. 服务器向客户端发送 Server Hello Done 报文，表明已经发送完所有握手消息。

（第三次）
6. 客户端向服务器发送 Client Key Exchange 报文，如果密钥交换选择 RSA 算法，由客户端生成预主密钥，使用服务器证书中的公钥对其加密，包含在报文中，服务器只需使用自己的私钥解密就可以取出预主密钥；如果密钥交换选择 DH 算法，客户端会在报文中包含自己的 DH 参数，之后双方都根据 DH 算法计算出相同的预主密钥。需要注意的是，密钥交换的只是预主密钥，这个值还需进一步加工，结合客户端和服务器两个随机数种子，双方使用 PRF（pseudorandom function，伪随机函数）生成相同的主密钥。
7. 客户端向服务器发送 Change Cipher Spec 报文，表明已经生成主密钥，在随后的传输过程都使用这个主密钥对消息进行对称加密。
8. 客户端向服务器发送 Finished 报文，这条消息是经过加密的，因此在 Wireshark 中显示的是 Encrypted Handshake Message。如果服务器能解密出报文内容，则说明双方生成的主密钥是一致的。

（第四次）
9. 服务器向客户端发送 New Session Ticket 报文，而这个 Session Ticket 只有服务器才能解密，客户端把它保存下来，在以后的 TLS 重新握手过程中带上它进行快速会话恢复，减少往返延迟。
10. 服务器向客户端发送 Change Cipher Spec 报文，同样表明已经生成主密钥，在随后的传输过程都使用这个主密钥对消息进行对称加密。
11. 服务器向客户端发送 Finished 报文，如果客户端能解密出报文内容，则说明双方生成的主密钥是一致的。至此，完成所有握手协商。


3.1.4 发送 HTTP 请求
建立起安全的加密信道后，浏览器开始发送 HTTP 请求，一个请求报文由请求行（请求方法、请求URL、HTTP协议及版本）、请求头(header)、空行、实体（也就是body，Get 请求没有body）组成。

请求头由通用首部、请求首部、实体首部、扩展首部组成。其中，通用首部表示无论是请求报文还是响应报文都可以使用，比如 Date；请求首部表示只有在请求报文中才有意义，分为 Accept 首部、条件请求首部、安全请求首部和代理请求首部这四类；**请求头看上去就是一堆Key：value，只不过有些Key 请求和相应都可以用，有些Key只能请求用，有些Key只有在有实体时来描述实体，有些Key是后来扩展的。**

实体首部作用于实体内容，分为内容首部和缓存首部这两类；扩展首部表示用户自定义的首部，通过 X- 前缀来添加。

另外需要注意的是，HTTP 请求头是不区分大小写的，它基于 ASCII 进行编码，而实体可以基于其它编码方式，由 Content-Type 决定。


3.1.5 返回 HTTP 响应
服务器接受并处理完请求，返回 HTTP 响应，一个响应报文格式基本等同于请求报文，由响应行、响应头、空行、实体组成。

区别于请求头，响应头有自己的响应首部集，比如 Vary、Set-Cookie，其它的通用首部、实体首部、扩展首部则共用。

此外，浏览器和服务器必须保证 HTTP 的传输顺序，各自维护的队列中请求/响应顺序必须一一对应，否则会出现乱序而出错的情况。

3.1.6 维持连接
完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。在 HTTP/1.1 中，请求报文的请求头有 Connection: keep-alive 是默认启用的，表示持久连接，以便处理不久后到来的新请求，**无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。**在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 **TCP keep-alive** 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。注意，HTTP keep-alive 和 TCP keep-alive 虽然都是一种保活机制，但是它们**完全不相同，一个作用于应用层，一个作用于传输层。**


3.1.7 断开连接
**四次挥手过程**

（这里的四次挥手可能有问题）

1、服务器向客户端发送 Alert 报文，类型为 Close Notify，通知客户端不再发送数据，即将关闭连接，同样，这条报文也是经过加密处理的。

2、服务器通过调用 close 函数主动关闭连接，向客户端发送带有 FIN 标志位的分组，序列号为 m。

3、客户端确认收到该分组，向服务器发送带有 ACK 标志位的分组，确认号为 m+1。客户端发送完所有数据后，向服务器发送带有 FIN 标志位的分组，序列号为 n。

4、服务器确认收到该分组，向客户端发送带有 ACK 标志位的分组，序列号为 n+1。客户端收到确认分组后，立即进入 CLOSED 状态；同时，服务器等待 2 个 MSL(Maximum Segment Lifetime，最大报文生存时间) 的时间后，进入 CLOSED 状态。


3.1.8 浏览器解析过程
//


3.1.9 主流程
//



3.1.10 渲染流程
//


3.1.11 页面生命周期
//






## 3.2 三次握手四次挥手什么意思？
详解       https://www.cnblogs.com/Andya/p/7272462.html
