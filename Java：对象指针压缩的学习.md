# 1 背景

最近在部署一个严肃的ES集群，大佬检查我的ES配置时指出，jvm的最大堆内存不能超过32g，否则会自动禁用对象指针压缩，从而导致对象头膨胀，最终导致频繁gc，知识盲区，学习记录一下。

参考文档：

讲一下JVM对象创建与内存分配机制     https://segmentfault.com/a/1190000023137581

JVM之压缩指针（CompressedOops）    https://my.oschina.net/xiaominmin/blog/3158911

HotSpot JVM中的对象指针零基压缩技术   https://blog.csdn.net/zjerryj/article/details/77206928

java对象内存分布图示  https://blog.csdn.net/qian_348840260/article/details/106547780

# 2 JVM对象创建与内存分配机制

jvm先读取各种jar包中字节码文件，在运行时结合对象的依赖关系动态计算对象的大小等对象的元信息，元信息部分的存储是不参与gc的。因此，如果自己肆无忌惮的调用classload极有可能导致OOM，；而CPP在编译时就通过相对地址位移将对象的大小等信息记录进代码区，而代码区之前的静态区也是在编译器就确定的，因此，CPP在编译阶段就已经做好了对象元信息的准备工作，所以CPP程序一般启动很迅速。


对象创建流程图：

![对象创建流程图](https://segmentfault.com/img/remote/1460000023137585)

逐步分析流程图中的几个流策节点：类加载检查、加载类（双亲委派）、分配内存、初始化、执行init方法。

## 2.1 类加载检查
虚拟机遇到一条new指令（new关键字、对象的克隆、对象的序列化等）时,会先去检查这个指令的参数（也即是类名）能否在常量池中定位到一个类的符号引用，如果有这个符号引用，就代表指令参数传入的类是是被加载过的，没有在常量池中定位到就去走类加载的流程（双亲委派）。


## 2.2 分配内存
类加载完毕后会给对象分配内存空间。对象的所需的内存大小在**类加载完毕后**就便可完全确认，为对象分配内存大小的空间等同于把一块确定大小的内存从java堆中划分出来。CPP同理，内存空间分配的本质就是申请内存空间（不一定是连续的，比如，下文的表量替换场景），然后在申请到的空间上进行后续的的初始化流程。

如何进行内存划分？
CPP中是申请一块连续的内存，或者 用内存池和placement new。Java中给对象划分内存空间的方式有多种：

1. 指针碰撞（默认的划分方法）

如果java堆内存是绝对规整的，那么会把所有用过的内存放在一边，空闲的内存放在另外一边，中间用一个指针来作为分界点的指示器，那所分配的内存仅仅把那个指针空闲空间的挪动一段与对象大小相同的距离。

2. 空闲列表

如果java堆内存不是绝对规整的，已使用的空间和未使用的空间互相交错，那么**虚拟机**维护一份列表，记录哪些内存块是可用的，在划分内存空间的时候从列表中找到一块足够大的内存空间分配给对象实例，并更新列表上的记录。

如果程序运行过程中，瞬间申请大量的的对象空间，上面两种方式显然有并发问题，于是有下面的两种分配方式。

3. CAS（compare and set，自旋锁，JNI）

虚拟机采用失败重试的机制方式保证操作的原子性对分配内存空间的动作进行同步处理，第一个线程抢占到了分配空间，第二个线程没有抢占到就重试抢占后面一块内存空间

4. 本地线程分配缓冲（TLAB）

把内存分配的动作按照线程分配在不同的空间之中完成，也就是每个线程在java堆中预先分配出一块小的内存。通过-XX：+/-UseTLAB参数来设定虚拟机是否使用（JVM默认开启-XX：+UseTLAB） ，-XX：TLABSize指定TLAB大小,默认是Eden区的百分之1，如果分配的对象超过TLAB能分配的大小，就走CAS分配方式


## 2.3 初始化

CPP中，对象实例的定义可以严格的分为：内存空间申请和在空间上进行值的初始化  这两步。其中，C的malloc只能做空间申请这一步，CPP的new是先调用malloc，如果有初始化调用，则再按构造函数中的语句描述进行初始化。

JAVA中，同样是的分配完毕后，给变量赋予默认值，如果使用了TLAB，变量赋予默认值的过程可以提前至TALB分配时进行。而**此处的初始化值是只包含申请空间+设置对象头+零值初始化**，调用构造函数是属于init部分的工作。

首先要知道JAVA中对象的内存模型：

![HotSpotJAVA对象内存分布](https://img-blog.csdnimg.cn/20200604153002532.png)



也就是：

对象头（再细分为：Mark word+Class pointer）+对象中的实际数据+对齐填充

因此，对象的初始化其实是JAVA对象所占用的内存空间进行初始化，也就是对  对象头、实际数据、对齐填充  的内存进行初始化。

### 2.3.1 对象头初始化

初始化零值之后，虚拟机要对对象实例进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息都存放在对象的对象头Object Header中。

![HotSpotJAVA对象头内存分布](https://segmentfault.com/img/remote/1460000023137584/view)

Mark Word标记字段(32位 4字节 ，64位占8字节)用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

对象头的另外一部分是类型指针（Class Point 开启压缩占4字节，关闭压缩占8字节），并不是Class ，我们使用的对象的getClass方法的那个Class对象是放在在堆内存区的，而Class point是类的元数据信息 ，即指向对象的元数据的指针，元数据信息本身是放在方法区之中，**虚拟机通过这个指针来确定这个对象是那个类的实例，类的元数据信息是放在CPP的对象来承载的**。

### 2.3.2 实例数据初始化
对象的实例数据就是改对象的引用大小



### 2.3.3 对齐填充初始化
保证对象是8个字节的整数倍。64位的机器每一行都是64位，如果现在8个字节直接取一行，那如果不是对齐，还要评估这个对象的大小，还要从这个对象大小的起始位置开始偏移，这样非常的麻烦，8个字节对齐是最优的寻址方式。对象的对齐填充还利用了空间局部性原理，充分利用了缓存机制。

### 2.4.4 对象的指针压缩是什么
JAVA中每个对象其实和CPP一样，也有指针，这个引用对象的指针叫 普通对象指针，是JVM中用于代表引用对象的句柄，oop（ordinary object pointer）。

对于32位机器，进程能使用的最大内存是4G。如果进程需要使用更多的内存，需要使用64位机器。

对于Java进程，在oop只有32位时，只能引用4G内存。因此，如果需要使用更大的堆内存，需要部署64位JVM。这样，oop为64位，可引用的堆内存就更大了。

在堆中，32位的对象引用占4个字节，而64位的对象引用占8个字节。也就是说，64位的对象引用大小是32位的2倍。

64位JVM在支持更大堆的同时，由于对象引用变大却带来了性能问题：

1. 增加了GC开销

64位对象引用需要占用更多的堆空间，留给其他数据的空间将会减少，从而加快了GC的发生，更频繁的进行GC。

2. 降低CPU缓存命中率

64位对象引用增大了，CPU能缓存的oop将会更少，从而降低了CPU缓存的效率。

为了能够保持32位的性能，oop必须保留32位。那么，如何用32位oop来引用更大的堆内存呢？

JVM的实现方式是，使用 零基压缩技术 ，不再保存所有引用，而是每隔8个字节保存一个引用，这样很大的内存的只需要较小的数字就能表示了。例如，原来保存每个引用0、8、16、24、32、40、48（最大用到了48），现在只保存0、4、8、12、16、20、24。因此，指针压缩后，并不是所有引用都保存在堆中，而是以8个字节为间隔保存引用。

在实现上，堆中的oop的值其实还是按照0x0、0x1、0x2...，64位的对象头能引用的堆内存范围已经及其的大了。例如，在启用对象头压缩的情况下，当引用被存入64位的寄存器时，JVM将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2...分别被转换为0x0、0x8、0x10。而当从寄存器读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方=32G。也就是说，使用32位，就能达到索引35位oop所能引用的堆内存空间）

Oracle JDK从6 update 23开始在64位系统上会默认开启压缩指针。

32位HotSpot VM是不支持UseCompressedOops参数的，只有64位HotSpot VM才支持。

对于大小在4G和32G之间的堆，应该使用压缩的oop。在64bit操作系统中，JVM支持指针压缩。

jvm配置参数：

启用指针压缩:­XX:+UseCompressedOops(默认开启)

禁止指针压缩:­XX:­UseCompressedOops

## 2.4 执行init方法
成员变量的赋值以及构造方法的调用


# 3 对象在内存中的位置及生命周期

## 3.1 分配的内存配置
JVM内存分配可以知道JAVA中的对象好像都是堆上进行分配，当对象没有被引用的时候，且堆内存占用达到限定值，JVM会自动进行GC，进行回收内存。如果对象数量较多的时候，会给GC带来较大的压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过**逃逸分析来**确定该对象不会被外部访问。**如果不会逃逸，可以将该对象在栈上分配内存，这样对象所占用的内存空间就可以随着栈帧出栈而销毁，就减轻了垃圾回收的压力。**

对象逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。

对于需要逃逸分析的场景，JVM对于函数栈帧中new出来的不会逃逸的情况，可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过**标量替换**优先分配在栈上(栈帧上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis) 。

标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该 对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就 不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认 开启。

标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（比如：int,long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，也就是聚合量。而JAVA中的对象就是可以被进一步分解的聚合量。


## 3.2 Minor GC 和Full GC 有什么区别？

MinorGC / Young GC：指的是新生代的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。

MajorGC / Full GC：一般指老年代，年轻代，方法区的垃圾回收，Major GC 的速度一遍比 Minor GC的慢10倍以上。



大量的对象被分配在Eden区，Eden区满了之后出发minor GC ，可能百分之99的对象都被当成垃圾回收掉，存活（标记）对象会被移动到Survivor，下一次当Eden区又满了之后会触发Minor GC把Eden区和Survivor区的存活对象移动到另一块Survivor区.每移动一次年龄加1，一直达到年龄15的时候会把移动到老年代。新生代的对象都是朝生夕死的，所以为了减少Minor GC的频率 尽量让Eden区尽量大 ，Survivor区够用即可。JVM默认比例已经很合适了，Eden与Survivor区默认8:1。

JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy。

分配了allocation1对象 这个时候Eden区几乎已经满了，下一步指令又要分配20M对象 ，Eden区已经不够给allocation2 分配内存空间了虚拟机触发Minor GC ，GC期间虚拟机发现结果From区只有10M放不下 ，所以只好把新生代对象提前存放到老年代，老年代的空间足够存放allocation1，剩下的对象JVM自身的一些类 比如：Object，加载器被移动到了From区。Minor GC完之后Eden区给 allocation2 对象分配内存

### 3.2.1 大对象直接进入老年代
大对象就是需要大量连续空间内存空间的对象比如：字符串，数组。JVM参数-XX:PretenureSizeThreshold可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在Serial和ParNew两个收集器下有效。

比如设置JVM参数-XX:+PrintGCDetails -XX:PretenureSizeThreshold=1000000（字节） -XX:+UseSerialGC ，在执行刚刚的代码这个时候发现大对象直接进入老年代

为什么这样设计？

为了避免为大对象分配内存时的复制操作而降低效率

### 3.2.2 长期存活的对象将进入老年代
JVM采用了分代年龄收集的思想，那么回收这个对象的时候就需要考虑放在Survivor还是老年代，考虑的依据虚拟机会为每个对象分配一个年龄计算器，如果对象在Eden区经过一次Monir GC后存活下的对象，移动到Survivor后年龄+1，之后的Minor GC每存活一次年龄再次+1 一直加到15（CMS默认是6，不同的垃圾收集器略不同），就会被移动到老年代。可以通过参数-XX:MaxTenuringThreshold来设置

### 3.2.3 对象动态年龄判断
如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。那么年龄大于或等于这批的对象将直接挪到老年代，例如：年龄1+年龄2+年龄3+年龄4+年龄N的对象 其中年龄1,2,3的对象总和超过了Survivor区域的百分之50（-XX:TargetSurvivorRatio可以指定），那么就会将3和3以上的对象都进入老年代。

### 3.2.4 老年代分配担保机制（触发Full GC）
年轻代每次Minor GC之前JVM都会计算下老年代剩余可用空间，如果这个可用空间小于年轻代里现有的所有对象大小之和（包括垃圾对象）就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了

如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。

如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full GC ，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生OOM

当然，如果Minor GC之后剩余存活的需要挪到老年代的对象还是大于老年代可用空间，那么也会触发Full GC ，Full GC完之后如果还是没有空间放Minor GC之后的存活对象，则会发生OOM

老年代分配担保机制担保的就是存在Full GC的情况下 减少一次Minor GC ，如果没有担保那么就是Minor GC->Full GC

## 3.3 内存回收机制
### 3.3.1 引用计数器

给对象中添加一个引用计数器，每当一个地方引用它，计数器就加；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最重要原因它很难解决对象之间互相循环引用的问题。所谓对象之间的互相引用问题，如下面代码所示：除了对象ObjA和ObjB互相引用着对方之外，这两个对象之间再无任何引用。但是因为他们互相引用对方，导致他们的引用计数器都不为0，于是引用计数算法无法通知GC回收他们

### 3.3.2 可达性分析算法
将GCRoots对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象标记为非垃圾对象，其余未标记的对象都是垃圾对象

GC Roots根节点: 线程栈的本地变量，静态变量，本地方法栈的变量等等

### 3.3.4 finalize()方法最终判断对象是否存活
即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这个时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程

标记的前提是对象在进行可达性分析法后发现没有与GC Roots相连接的引用链。

1. 第一次标记并进行一次筛选

筛选的条件就是该对象是否覆盖了finalize()方法，没有覆盖直接回收

2. 第二次标记

如果这个对象覆盖了finalize()方法，只要重新与引用链上任何一个对象关联即可，比如把自己赋值给某个类的变量或对象的成员变量，那么第二次标记的时候它将移除“即将回收”的集合。

注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次

### 3.3.5 如何判断一个类是无用的类？
方法区主要回收的是无用的类，如何判断一个类是无用的类

类需要满足下面三个条件才能算是无用的类：

1. 该类的所有实例都被回收，Java堆中没有存在该类是任何实例

2. 加载该类的ClassLoader被回收（只有自定义的类加载器才能被回收）

3. 该类的对应的Java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

