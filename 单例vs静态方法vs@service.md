@[TOC]
# 1 三者的简介
## 1.1 单例
就是这个类只能创建一个实体类，也就是没有public的构造方法，只有一个get方法来获得该一个该类的实例，单例的几种写发详见<https://blog.csdn.net/jeason_chan_zju/article/details/98798261>，推荐最后一种，使用内部静态类的单例写法。
单例的特点是，所有能获得单例实例的地方，都能够“共享”单例中的数据，利用率很高，一定程度上减少了不断重复创建实例对象的内存和CPU消耗。
## 1.2 @service
假设@service Class B；则B是一个服务类，要使用这个类的功能需要先在自己的属性中定义一个B的实例，然后进行@inject注解，整个过程如下：
**B.java**
```java
@service
class B{
	//服务类
}
```
**A.java**
```java
class A{
	@inject
	private B b;
}
```
程序启动时，框架会自动实例化一个B，并且，A中会自动注入这个实例化出来的B的实例。
但是！！！！你自己仍然是是可以手动再创建B的实例的，并且，框架实例化B的服务实例的过程是不受程序员控制的，一切都是都是自动的，因此，在service内再去使用其他的service的话，由于框架实例化service类的先后顺序不同，极有可能获去service时，该service还是null的，这点尤其注意！慎用service！
## 1.3 静态方法
静态方法，就是不通过实例实例调用一些方法，显著的特征调用方法时不会改变共享的数据，但是，可以读取，比如，一个类实例转json串的静态方法，ObjectMapper实例作为是static 属性，用来在静态方法中共用。
# 2 使用场景
## 2.1 相同点
三者都是资源重复/高效利用 ，减少内存和CPU开支的方式
## 2.2 不同点（个人观点）
1. static 方法，一般不会去改变类中的static 属性，有一种用完即走的感觉
2. 单例，比较适合方法操作中要改变属性的从场景
3. service，比较不受控，**个人感觉**，能单例就使用单例吧……



