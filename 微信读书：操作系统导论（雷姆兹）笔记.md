在此记录看书过程中的笔记和重要。

# 第2章 操作系统介绍

一个正在运行的程序会做一件非常简单的事情：执行指令。处理器从内存中获取（fetch）一条指令，对其进行解码（decode）（弄清楚这是哪条指令），然后执行（execute）它（做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器继续执行下一条指令，依此类推，直到程序最终完成。这些指令的执行就是依赖各种各样的寄存器，在现代处理器中，为了提高程序运行的速度，有些编译器会对程序写出来的顺序结构进行优化，生成乱序执行的汇编（汇编中，很多助记符就是对应了一个CPU的操作），本书考虑的情况，是大多数情况下的汇编也是顺序而非乱序的情况。


操作系统的目的就是让我们充分、高效的利用有限的硬件资源，为了实现这样一个明确的目的，操作系统需要做好三个关键点：虚拟化、并发、持久化。


操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）。

典型的操作系统会提供几百个系统调用（system call），让应用程序调用。由于操作系统提供这些调用来运行程序、访问内存和设备，并进行其他相关操作，我们有时也会说操作系统为应用程序提供了一个标准库（standard library）。

## 2.1 虚拟化CPU
事实证明，在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的假象。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizing the CPU），这是本书第一大部分的关注点。通过虚拟化的CPU（其实就是时间切片），是单核CPU也能看上去像能并行运行是程序。


## 2.2 虚拟化内存

程序运行时，必然要先将程序（包括指令、数据）从外存读取到内存，然后程序的每个指令都在内存中，因此每次读取指令都会访问内存（其实也不是，会有指令缓存）。

每个进程访问自己的**私有**虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。

这就是操作系统的虚拟内存技术，每个进程里的内存地址其实都是相对地址，只有操作系统知道该进程真正的起始地址，并将进程的相对地址转换为物理地址（其实也不是物理地址，物理地址之上还有一层逻辑内存，真是因为逻辑内存，才有内存映射技术，现代计算机的内存几乎可以做到无限大）。

## 2.3 并发
注意并发和并行的区别，并发能发生在单核机器中，通过多线程（时间切片）的方式实现“同时”y运行多个程序，并行只可能发生在多核机器中，分别给每个核心提交任务，每个核心上的任务才是真正意义上的并行。

典型的并发问题：

```cpp
volatile int a=10;


//多线程中的某一句话
a++;
```

volatile关键字的作用是，告诉编译器，生成汇编时每次都要去主存中读a的值，不要将a优化放到寄存器中。和java中的一样，volitate关键字只能保证可见行，真正对该变量进行自增操作时，还是要：1、先把旧只读到寄存器里，2、运行加法运算，3、再从寄存器回写到内存中；显而易见，自增操作不是原子操作，尤其是的会写步骤，可能会覆盖别的线程刚刚回写完的值，发生更新丢失现象（和数据库的中，事务操作的更新丢失原理简直一模一样。）

因此，操作系统还有提供一些方法帮助解决并发问题。

## 2.4 持久性

RAM中的数据断电会丢失，因此需要硬件和软件来持久地（persistently）存储数据。这样的存储对于所有系统都很重要，因为用户非常关心他们的数据。

硬件以某种输入/输出（Input/Output，I/O）设备的形式出现。


操作系统中管理磁盘的软件通常称为文件系统（filesystem）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。

不像操作系统为CPU和内存提供的抽象（操作系统抽象除了虚拟CPU和虚拟内存），操作系统不会为每个应用程序创建专用的虚拟磁盘。相反，它假设用户经常需要共享（share）文件中的信息。


对于的典型的读写文件流程：创建/打开文件、写入数据、关闭文件，需要**进行三个系统调用**。第一个是对open()的调用，它打开文件并创建它。第二个是write()，将一些数据写入文件。第三个是close()，只是简单地关闭文件，从而表明程序不会再向它写入更多的数据。这**些系统调用（system call）被转到称为文件系统（file system）的操作系统部分，然后操作系统处理这些请求，并向用户返回某种错误代码。**

操作系统提供了一种通过系统调用来访问设备的标准和简单的方法，我们不必跟直接跟各种设备的驱动直接进行交互。因此，OS有时被视为标准库（standardlibrary）。

出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复**杂的写入协议**，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。

## 2.5 设计目的

操作系统的任务：它取得CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。


# 3 关于虚拟化的对话
操作系统就是分为三个部分的功能：虚拟化、并发、持久性。接下来的好几章节的内容是都是操作系统为了CPU和内存虚拟化所做的一些系统设计。



