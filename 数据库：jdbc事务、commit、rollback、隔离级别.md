# 1 事务

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务时一系列的DML、DFL、DCL语句的**有序**集合，事务具有4个特性：ACID，分别是：

原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性（Consistency）：事务前后数据的完整性必须保持一致。

隔离性（Isolation）：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。

持久性（Duration）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

## 1.1 原子性

以A账户向B账户转100块  这个事务 为例，事务中的动作包括A的钱扣100和B的钱增加100。如果对B的账户增加100块是出现了异常，则整个事务回滚（未commit，DML语句只是写入日志并没写入表），撤销在日志中  该事务的所有操作。如果所有的操作都成功，则操作从日志中持久到对表的修改。

原子性表现在，**事务中的所有的sql操作，要么同时生效到表中，要么同时从日志中全部撤销出来。**

## 1.2 一致性

事务完成后，符合逻辑运算

## 1.3 持久性

表示事务结束（结束的标志是commit和rollback，主动链接不算结束标志）后的数据，不会因为外界原因导致数据丢失。

如果在事务还没有提交（只是写入日志，为生效到表中），服务器宕机或者断电（connection突然断开），那么重启数据库以后，表的状态应该为  事务开始之前的状态。
 如果在事务已经提交（写入了日志和表），服务器宕机或者断电，那么重启数据库以后，表的状态应该为 事务成功后的状态。

## 1.4 隔离性

针对多个事务同时对数据库操作，主要是允许其他事务对本事务的影响程度，其他事务对本事务的影响程度就是当前事务开始定义的隔离性。

因为事务的隔离性级别带来的常见三个问题为：

* 脏读

指一个事务读取了另外一个事务未提交的数据，也就是读取了，别的事务写到日志里的一系列动作，但是，别的事务有可能会rollback。

比如：

1、Mary的原工资为1000, 财务人员将Mary的工资改为了8000(但未提交事务)         

2、Mary读取自己的工资 ，发现自己的工资变为了8000，开心的一批

3、而财务发现操作有误，回滚了事务，Mary的工资又变为了1000

Mary记取的工资数8000是一个脏数据

解决办法：设置当前事务隔离别READ_COMMITTED，只读取别的事务COMMITTED之后的，只读取commit之后，应该是读取的底线了。

* 不可重复读

在一个事务内读取表中的某一行数据的某一个或者多个字段，多次读取结果不同。（这个不一定是错误，只是某些场合不对）。也就是，在别的事务提交前后，读取了同一行的数据，恰好别的事务修改了该行，两次读取的结果不同，造成**读取操作不具有幂等性了**。

比如：

1、在事务1中，Mary 读取了自己的工资为1000，操作并没有完成

2、在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.

3、在事务1中，Mary 再次读取自己的工资时，工资变为了2000

解决办法：设置当前事务级别是REPEATABLE_READ

不可重复读和脏读看上去很像，一个是读取了别人事务commit之后的结果，一个是读取了为commit并且rollback的结果。

* 幻读

当前事务正在读取某些行的范围时，如果有另外的事务对这些行进行了**插入或删除**操作。比如，事务第一次读的行范围中的一行或者多行已不存在于第二次读或后续读取中，因为该行已被其它事务删除。同样，由于其它事务的插入操作，事务的第二次或后续读显示有一行相比于原始读取的行，是多出来的。

举个例子， 目前工资为1000的员工有10人。

1、事务1，读取所有工资为1000的员工，显然是10条记录了

2、这时事务2向employee表插入了一条员工记录，工资也为1000

3、事务1再次读取所有工资为1000的员工 共读取到了11条记录 

解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以 **添加/删除** 新数据，则可避免该问题。也即是隔离级别设置为，TRANSACTION_SERIALIZABLE

* 更新丢失问题

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。**最后的更新将重写由其它事务所做的更新，这将导致数据丢失。** 　　

比如：事务A和事务B同时修改某行的值，两者先同时读取了原始的该行数据，事务A先将数值改为1并提交，这时事务B将数值改为2并提交，事务A所做的更新将会丢失。

解决办法：对行加锁，只允许并发一个更新事务

为了解决事务的并发问题，数据库的标准隔离级别有四种，以JDBC中 connection的隔离级别参数为例：

| 设置                         | 描述                                                         | 脏读   | 不可重复读 | 幻读   |
| ---------------------------- | ------------------------------------------------------------ | ------ | ---------- | ------ |
| TRANSACTION_SERIALIZABLE     | 在一个事务中进行查询时，不允许其他事务对这个查询表的数据修改。 | 不允许 | 不允许     | 不允许 |
| TRANSACTION_REPEATABLE_READ  | 当前事务读取时，不读取其他事务update后的数据，不锁表；但是**可以读取新增的数据**。 | 不允许 | 不允许     | 允许   |
| TRANSACTION_READ_COMMITTED   | 当前事务只读取其他事务提交的数据；当前事务update操作时不锁表。 | 不允许 | 允许       | 允许   |
| TRANSACTION_READ_UNCOMMITTED | 能够读其他事务未提交的数据                                   | 允许   | 允许       | 允许   |



# 2 commit和rollback

Structured Query Language- - -结构化查询语言
有 数据定义语言(DDL)，例如：CREATE、DROP、ALTER等语句；
数据操作语言(DML)，例如：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句；
数据查询语言(DQL)，例如：SELECT语句；
数据控制语言(DCL)，例如： COMMIT、ROLLBACK、GRANT、REVOKE等语句

不管是什么的sql的客户端，本质上都是通过client（这里特指图形界面和终端）和server端之间的connection执行SQL语句的，一般情况下，我们在client中输入语句，执行一下，就立刻生效到表中，是因为，当前的这个client设置了autocommit，每输入执行一条语句，就commit当前执行的语句。

由于事务隔离级别的不同，不同的数据库浏览器查到的数据可能是不同的，但是，数据库浏览器的隔离级别一般都是READ_COMMITED级别的。

**一般情况下，事务的DML操作，未commit之前，都是只是写在日志中的，未生效到表中。但是！！！DDL操作，会先隐式单独提交。但是，DDL中的drop命令有点特殊，如果事务还未结束，drop命令会被阻塞。**

rollback操作，会撤回日志中DML结果。

# 3 JDBC的事务操作

```java
Class.forName(driverClassName);
connection = DriverManager.getConnection(url, username, password);

connection.setAutoCommit(false);//设为false，关闭自动提交；对数据库的更改生效只发生在commit之后
// 为true时，每句statement执行都是一条事务；

//JDBC默认隔离级别是4 可重复读级别，可避免不可重复读，不可避免幻读
System.out.println("当前事务隔离级别是：" + connection.getTransactionIsolation());

connection.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);

statement = connection.createStatement();
```

JDBC3.0 中新增了保存点：https://www.yiibai.com/jdbc/jdbc-transactions.html