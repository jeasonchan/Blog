在此记录看书过程中的笔记和重要。

# 第2章 操作系统介绍

一个正在运行的程序会做一件非常简单的事情：执行指令。处理器从内存中获取（fetch）一条指令，对其进行解码（decode）（弄清楚这是哪条指令），然后执行（execute）它（做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器继续执行下一条指令，依此类推，直到程序最终完成。这些指令的执行就是依赖各种各样的寄存器，在现代处理器中，为了提高程序运行的速度，有些编译器会对程序写出来的顺序结构进行优化，生成乱序执行的汇编（汇编中，很多助记符就是对应了一个CPU的操作），本书考虑的情况，是大多数情况下的汇编也是顺序而非乱序的情况。


操作系统的目的就是让我们充分、高效的利用有限的硬件资源，为了实现这样一个明确的目的，操作系统需要做好三个关键点：虚拟化、并发、持久化。


操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）。

典型的操作系统会提供几百个系统调用（system call），让应用程序调用。由于操作系统提供这些调用来运行程序、访问内存和设备，并进行其他相关操作，我们有时也会说操作系统为应用程序提供了一个标准库（standard library）。

## 2.1 虚拟化CPU
事实证明，在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟CPU的假象。将单个CPU（或其中一小部分）转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU（virtualizing the CPU），这是本书第一大部分的关注点。通过虚拟化的CPU（其实就是时间切片），是单核CPU也能看上去像能并行运行是程序。


## 2.2 虚拟化内存

程序运行时，必然要先将程序（包括指令、数据）从外存读取到内存，然后程序的每个指令都在内存中，因此每次读取指令都会访问内存（其实也不是，会有指令缓存）。

每个进程访问自己的**私有**虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。

这就是操作系统的虚拟内存技术，每个进程里的内存地址其实都是相对地址，只有操作系统知道该进程真正的起始地址，并将进程的相对地址转换为物理地址（其实也不是物理地址，物理地址之上还有一层逻辑内存，真是因为逻辑内存，才有内存映射技术，现代计算机的内存几乎可以做到无限大）。

## 2.3 并发
注意并发和并行的区别，并发能发生在单核机器中，通过多线程（时间切片）的方式实现“同时”y运行多个程序，并行只可能发生在多核机器中，分别给每个核心提交任务，每个核心上的任务才是真正意义上的并行。

典型的并发问题：

```cpp
volatile int a=10;


//多线程中的某一句话
a++;
```

volatile关键字的作用是，告诉编译器，生成汇编时每次都要去主存中读a的值，不要将a优化放到寄存器中。和java中的一样，volitate关键字只能保证可见行，真正对该变量进行自增操作时，还是要：1、先把旧只读到寄存器里，2、运行加法运算，3、再从寄存器回写到内存中；显而易见，自增操作不是原子操作，尤其是的会写步骤，可能会覆盖别的线程刚刚回写完的值，发生更新丢失现象（和数据库的中，事务操作的更新丢失原理简直一模一样。）

因此，操作系统还有提供一些方法帮助解决并发问题。

## 2.4 持久性

RAM中的数据断电会丢失，因此需要硬件和软件来持久地（persistently）存储数据。这样的存储对于所有系统都很重要，因为用户非常关心他们的数据。

硬件以某种输入/输出（Input/Output，I/O）设备的形式出现。


操作系统中管理磁盘的软件通常称为文件系统（filesystem）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。

不像操作系统为CPU和内存提供的抽象（操作系统抽象除了虚拟CPU和虚拟内存），操作系统不会为每个应用程序创建专用的虚拟磁盘。相反，它假设用户经常需要共享（share）文件中的信息。


对于的典型的读写文件流程：创建/打开文件、写入数据、关闭文件，需要**进行三个系统调用**。第一个是对open()的调用，它打开文件并创建它。第二个是write()，将一些数据写入文件。第三个是close()，只是简单地关闭文件，从而表明程序不会再向它写入更多的数据。这**些系统调用（system call）被转到称为文件系统（file system）的操作系统部分，然后操作系统处理这些请求，并向用户返回某种错误代码。**

操作系统提供了一种通过系统调用来访问设备的标准和简单的方法，我们不必跟直接跟各种设备的驱动直接进行交互。因此，OS有时被视为标准库（standardlibrary）。

出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复**杂的写入协议**，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。

## 2.5 设计目的

操作系统的任务：它取得CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。


# 第3章 关于虚拟化的对话
操作系统就是分为三个部分的功能：虚拟化、并发、持久性。接下来的好几章节的内容是都是操作系统为了CPU和内存虚拟化所做的一些系统设计。

虚拟化要做的就是将这个CPU虚拟成多个虚拟CPU并分给每一个进程使用，因此，每个应用都以为自己在独占CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象—它虚拟化了CPU。


# 第4章 抽象：进程
进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。

时分共享（time sharing）是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间。时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。

## 4.1 抽象：进程
一个进程只是一个正在运行的程序。在任何时刻，我们都可以清点它在执行过程中访问或影响的系统的不同部分，从而概括一个进程。

机器状态（machine state）：程序在运行时可以读取或更新的内容。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器。有一些非常特殊的寄存器构成了该机器状态的一部分。例如，程序计数器（Program Counter，PC）（有时称为指令指针，Instruction Pointer或IP）告诉我们程序当前正在执行哪个指令；类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于管理函数参数栈。程序也经常访问持久存储设备。此类I/O信息可能包含当前打开的文件列表。

## 4.2 进程API

创建（create）：操作系统必须包含一些创建新进程的方法。在shell中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。

销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，用户可能希望终止它们，因此停止失控进程的接口非常有用。

等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。

其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。

状态（statu）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。


## 4.3 进程创建：更多细节
操作系统运行程序**必须做的第一件事是**将代码和所有静态数据（例如初始化变量）加载（load）到内存中，也就是加载到**进程的地址空间**中。

将代码和静态数据加载到内存后，操作系统在运行此进程之前还**需要执行其他一些操作。必须为程序的运行时栈（run-timestack或stack）分配一些内存**。比如，C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。操作系统也可能会用参数初始化栈。具体来说，它会将参数填入main()函数，即argc和argv数组。

同时，每个进程有默认进行的IO，比如，在UNIX系统中，默认情况下每个进程都有3个打开的文件描述符（file descriptor），用于标准输入、输出和错误。


通过：

1、将代码和静态数据加载到内存中

2、通过创建和初始化栈以

3、执行与I/O设置相关的其他工作

OS现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序，在入口处运行，即main()，OS将CPU的控制权转移到新创建的进程中，从而程序开始执行。


## 4.4 进程状态
进程可以处于以下3种状态之一：

1、运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。

2、就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。

3、阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，**当进程向磁盘发起I/O请求时，它会被阻塞**，因此其他进程可以使用处理器。

一旦进程被阻塞（例如，通过发起I/O操作），OS将保持进程的阻塞状态，直到发生某种事件（例如，I/O完成）。此时，进程再次转入就绪状态（也可能立即再次运行，取决于操作系统的调度)。

为什么进程一发生IO就要阻塞呢？有IO则必然有等待，为了保持CPU繁忙来提高资源利用率，可将时间片暂时划分给其他进程。其次，当I/O完成时，系统也决定不切换回Process0，取决于OS的调度策略。

## 4.5 数据结构
操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的信息，比如，为了跟踪进程的信息，必然有一套完善的数据结构用来描述进程，本质上就是描述进程的**机器状态**。


对于停止的进程，**寄存器上下文（专有名词，一个数据结构）**将保存其寄存器的内容。当一个进程停止时，它的寄存器中的值将被保存到内存中的寄存器上下文对象中。通过恢复这些寄存器（将它们的值从内存中读取并放回实际的物理寄存器中），操作系统可以恢复运行该进程。


一个进程还可以处于已退出但尚未清理的最终（final）状态（在基于UNIX的系统中，这称为僵尸状态）。这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行。父进程将进行最后一次调用（例如，wait()），以等待子进程的完成，并告诉操作系统可以清理这个正在结束的进程的所有相关数据结构。


进程列表（process list）：任何能够同时运行多个程序的操作系统当然都会有类似这种结构的东西，以便跟踪系统中正在运行的所有程序。有时候人们会把存储关于进程的信息的个体结构称为进程控制块（Process ControlBlock，PCB），这是谈论包含每个进程信息的C结构的一种方式。

# 第5章 插叙：进程API
