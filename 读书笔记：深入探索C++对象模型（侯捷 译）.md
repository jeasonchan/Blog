# 0 背景
读书的过程中，除了阅读原始书籍之外，同时还参考了部分老哥的笔记。

参考文章：

xiezhw3/Inside-the-C-plus-plus-Object-Model-note   https://github.com/xiezhw3/Inside-the-C-plus-plus-Object-Model-note/tree/master/%E7%AC%94%E8%AE%B0


这本书主要讲两个方面的问题：

1. 一个真实的运行时的CPP对象在内存中的样子？
2. 编译器为了维护CPP的面向对象的"生态"，对我们的源码做了什么？

# 1 关于对象


## 1.1 C++对象的内存模型


### 1.1.1 简单对象模型

巴拉巴拉

### 1.1.2 表格驱动对象模型

巴拉巴拉

### 1.1.3 C++对象模型
是C++最初的内存模型：

1. 非静态的数据成员存在于每个对象实例中，即占用对象实例的内存
2. 静态的数据成员对象不会占用对象实例的内存
3. 静态和非静态的的成员函数不占用对象实例的内存
4. 虚函数通过以下机制来实现：有虚函数的类都有自己的虚函数表，子类覆写了父类虚函数后，虚函数表中指向的函数就变成了子类的函数；每个有虚函数的对象实例的第一个成员对象都是指向那个虚函数表的指针，叫虚表指针，虚表指针有且只有一个。

这个对象模型的优点：

1. 能抽出来共用的部分基本都共用了，已经有很高的空间和存取效率了

缺点：

1. 某类增加了非静态数据成员后，编译生成的内存模型必然发生了变化，这就导致使用该类的程序都要重新编译，也就是没有做到 二进制兼容性；表格驱动的对象模型就没有这个问题，对象里面只有两个指针的空间占用。

### 1.1.4 继承关系在对象模型中的体现
C++支持单一继承、多重继承、虚继承（http://c.biancheng.net/view/2280.html，解决菱形继承的场景中公用基类的冗余问题），那派生类的这种派生关系的在内存模型中是如何体现的？


对于简单对象模型，用一个slot指向父类即可，优点是父类结构发生变化，对子类无影响，能保证子类的二进制的兼容性。缺点是，用指针作为一个中间层，要用指针跳转一次，影响性能。


对于表格驱动的对象模型，模仿虚函数的实现过程造一个基类表，也就是一个实例对象会有三个指针了：指向数据成员表的指针、指向函数表的指针、基指向类表的指针。


简单对象模型和表格驱动对象模型在实现继承时，都无法避免指针间接引用带来的性能损耗。C++**最初的**对象模型为了实现较高的性能，直接将父类的成员放到子类中，也就是对象实例的内存分布上，**越靠前部分的内存，越是父类的非静态数据成员。**缺点，自然是的父类的改变会导致子类的二进制兼容问题。

C++对象模型为了实现虚继承，和虚函数的处理方式类似，也使用了间接的方式。最原始的处理方法是，使用一个虚继承表。

### 1.1.5 对象模型如何影响程序
编译器会偷偷修改的我们写的代码，比如RVO优化等等，内存模型对我们写的代码同样有很大的影响，比如：虚函数的调用

```cpp
class X {
    virtual void handle(){
        //do sth
    }

};



void a_function(){
    X x1;
    X p_x*=new X;

    //编译器转译为：
    //handle(&x1)
    x1.handle();
    
    //编译器转移为：
    //(*(p_x->vptr[2]))(p_x)
    //即，从vptr指向的虚函数表中，找到第二个函数的地址，再对函数地址解引用，实现函数调用
    p_x->handle();


    //虚函数的多态只能通过指针和引用，直接通过实例名无法实现，所以上面通过对象直接调用需函数时没有走虚函数表的查找过程

}

```

可见，对象内存模型对编译器的影响十分重大


## 1.2 关键词带来的差异
C和C++中的关键词带来的差异……这本书感觉讲得乱七八糟的……是侯捷翻译的不好吗？？？读完这一小结后，发现是在讲struct关键字在两种语言使用过程中的差异。

C++中的struct和class关键字，除了默认的成员可见性不同，其他完全相同，而C中的struct只能含有数据成员对象。

个人觉得pure cpp就不要强行使用C风格的东西了，真的要强行混合使用C的struct和cpp的对象时，单独将C的结构体抽出来，封装成一个纯粹的C的struct。


## 1.3 对象的差异

C++的程序设计模式直接支持多种模式：面向过程、面向对象、泛型编程（STL就是泛型编程的典范）。

要想实现多态，必须通过指针或者引用进行调用，比如：

```
//走虚函数表的
X *p=new X();
X &r=(*p);

p->fun();
(*p).fun();
r.fun();



//不走虚函数表，直接调X::fun(X*)这个函数
//这一语句其实是初始化x
X x=*p; 
x.fun()
```

一个实例对象的内存占用大小包括：
1. 所有非静态成员对象的大小
2. padding所加进去的字节，padding的目的就是将对象所占内存大小调整为最大寻址地址的整数倍。比如，编译为32位的程序，则应该为32位（即4字节）的整数倍
3. 处理各种virtual带来的内存占用，也就是几个固定大小的指针。


### 1.3.1 指针的类型
指向不同对象、基本类型的指针，有什么不同？从内存的角度看，完全一样，都只是持有一个虚拟地址空间的地址而已，指针类型只是告诉编译器从地址往后取多少字节是这个对象的内存地址范围,编译器知道类型后才能进行各种操作。

所以，编译器拿到void\*类型的指针，毫无乱用，只是拿到了一个对象的起始地址，这个对象占了多少自己并不知道，然后就什么也不能做了，除非做一些强制转换再使用。

所以，转换（cast）其实算一种编译器指令，没有改变起始地址，而是告诉编译器读取的字节长度，本质上，cast操作是改变了编译器读取并解释字节的方式。

### 1.3.2 考虑多态
