# 1 开始

```cpp
#include <iostream>

using namespace std;

int main()
{
    cout << "标准输出" << endl;
    cerr << "标准错误" << endl;
    clog << "运行时消息" << endl;

    cout << "输入两个数字：" << endl;

    int number1;
    int number2; //

    cout << "初始化为：" << number1 << " " << number2 << endl;

    cin >> number1 >> number2; //一直会阻塞直到输入了两个非空的字符

    cout << "number1:" << number1 << "  number2:" << number2 << " and sum is " << number1 + number2 << endl;

    cout << "/*" << endl;
    cout << "/*" << endl;

    // while语句
    int sum = 0, val = 1;
    while (val <= 10)
    {
        sum += val;
        val++;
    }
    cout << "sum=" << sum << endl;

    bool haha = true;

    sum = 0;
    val = 10;

    while (val >= 1)
    {
        sum += val;
        --val;
    }

    sum = 0;
    val = 50;
    for (; val > 0; ++val)
    {
        sum += val;
    }

    sum = 0;
    val = 0;
    //while的判断条件是 cin>>val  这个表达式的值
    //也就是  >>  这个函数的值，也就是标准输入流  cin
    //当cin遇到 文件结束符（eof） 或者 无效输入时，cin的状态为无效状态，即为false
    //其与可以人为时有效的
    while (cin >> val)
    {
        cout << "Got:" << val << endl;
        sum += val;
    }

    //想推出以上循环，就只能故意输进去字符，强制cin无效；或者，ctrl+z然后enter，输入文件结束符

    cout << "end and sum is " << sum << endl;

    return -1;
}
```

未初始化的变量：

基本数据类型声明时，确实会有一个初始值，但是，是不确定的初始值。类 类型的变量如果未指定初始值，就会自动调用无参构造（可能时编译器自动添加的无参构造）。类类型的成员变量，在为对象申请内存时就会按照类成员定义的先进行一波初始化，**然后才会开始**调用构造函数，所以，为了避免在构造函数中**二次初始化**自定义类型的成员变量，引入了参数列表。

```cpp
private:
    string s_;

public:
Base(const string& s) 
{ 
    s_.string::string(s); 
} 

/* 
真是的执行顺序是：

string s_;//在构造函数之前先执行

Base(const string& s) { 
    s_=s;//这是一个左值赋值函数，会不会有较大的性能开销看string的=实现
} 
*/

```

# 2 变量和基本类型
## 2.1 内置的基本类型
cpp和java一样，虽然都是面向对象的，本应该是一切皆对象（cpp其实可以多种，过程、对象、函数式，都可以），但还是有的旧时的影子，那就是基本数据类型。

cpp的基本数据类型，分为算术类型和空类型（void）。

### 2.1.1 算数型
算数型还分为：
* 整型，包括 bool、char、wchar_t、char16_t char32_t、short、int、long long、long
* 浮点型，包括 float、double、long double

整型之所以叫整型，不仅体现在代表一个整数，在内存中，递增是通过向低位+1实现的，而浮点型是**个人猜测**，会像java一样，某些位是指数位。

每种类型的占用的比特位数稍有不同。其中最坑的莫过于字符相关的整型：char、wchar_t、char16_t、char32_t,稍有不慎就会发生截断，造成字符显示异常。

C++读写汉字，C++处理中文字符             https://blog.csdn.net/calmreason/article/details/7935258

C++11新特性--Unicode 16位和32位支持           https://www.jianshu.com/p/8b87a05c23b1

浅谈char类型范围（原码、反码、补码）       https://blog.csdn.net/zy986718042/article/details/71699079


内置类型的机器实现：

<!-- 补充实现 -->

可寻址的最小内存块  字节，现代操作系统固定为8比特（1比特=1位）

存储的基本单元  字，4字节或者8字节

整型中除了布尔型，还可以分为：有符号型和无符号型，默认的int、long、long long是有符号的。

比较特殊的是char、signed char、unsigned char，尽管看上去是三种，但是，**因编译器实现而异，char必然是unsigned char和signed char其中的一种**。unsigned char能表示0到255，signed char能表示-128到127。不过，ASCII一共只有128个字符，无符号和有符号的char会用非负数表示ASCII中的字符。

由于cpp就是为了性能而生，且为了合理、充分利用硬件，cpp的基本数据类型有很多种，所以**如何选择类型？选择数据类型的标准是什么？**

1. 明确知道类型为非负时，使用unsigned的数据类型
2. 一般使用int。int不够用时，建议直接使用long long，因为long一般和int有一样的位数
3. 不要char或者bool进行算数计算，以为你char的有无符号取决于编译器实现，实在想用务必显式声明signed char或者 unsigned char
4. 浮点数运算建议直接使用double。因为，因为float消耗并没有比double少多少，甚至有时候float还比double慢

### 2.1.2 类型转换
一个对象的定义，包含了的该对象包含的数据，还包含了能参与的运算/方法，其中有一种运算被大多数数据类型所支持，那就是类型转换。类型转换，是指，当某个日地方的参数因该是某种类型，但是我们却给定了另一种（能进行转换的）类型，则**编译器会自动将我们使用的数据类型自动转换为入参期望的数据类型**。Java下也有一样的特性，java支持低精度往高精度转，而高精度向低精度转这种发生数据截断的情况会报错。

cpp中的类型转换会在以下2种情况发生：

1. 显式的赋值语
```cpp
bool b=42;//b为真，数字类型向布尔转换，0转成false，其余转为true
int i=b;//布尔值向数字类型转换，true转为1，false转为0
i=3.14;//i被截断为3
double pi=3;//pi是3.0
unsigned char c=-1;//假设char是8bit的，则c是对2^8取模的余数，即为256-1=255
signed char c2=256;//假设char是8bit的，由于cpp并不规定有符号数的具体实现，无法确定的最终的值，c2为未定义
```

2. 当程序中使用一种算术类型，但是，实际上需要另一种类型时，编译器会自动执行类型转换
```cpp
int i=666;
/*
在if的判断条件中，i会自动转为true
*/
if(i){
    //xxxxxxx
}
```
个人觉，还有种其中，比如的某个类的构造函数的入参就只有一个算术类型，使用赋值语句时，有可能自动调用构造函数，详见explict关键字用法



#### 2.1.2.1 无符号类型注意点
对于无符号类型，超过范围的数都会通过取模运算自动转换到范围内，且不会报错，极有可能的造成死循环。

无符号数之间进行运算时，务必要提前判断结果是否会超出范围而发生取模运算。

同时，有符号和无符号进行运算时，**有符号首先被转换成无符号**，在进行无符号数之间的运算，无符号数之间的**运算结果还有可能超出无符号数的范围，再次发生取模运算**。由于这个操作比较复杂，所以**绝对不要进行**无符号和有符号的混合运算。

### 2.1.3 字面值常量
一看就知道值的常量就是字面值常量，字面值常量的形式和值的大小决定了该字面值常量的数据类型。

#### 2.1.3.1 整型和浮点型字面值常量
对于十进制整型，如:123，44444444444444444444444444，在能容纳字面值常量的前提下按照int、long、long long先后顺序当做字面值常量的类型。

对于八进制（比如，024）、十六进制（比如，0x14）也有类型的数据类型顺序。

尽管整型字面值可以存储在有符号类型中，但是，**严格来说十进制字面值不会是负数**，-42这种只是对十进制字面值常量取负值而已。

#### 2.1.3.2 字符和字符串字面值

```cpp
'a';//由单引号括起来的一个字符被称为char型字面值
"2333333";//由双引号括起来的两个或者多个字符则构成字符串型字面值
```

字符型字面值就真的表示一个字符，字符串型字面值的长度会被看到的长度多1，因为，字符串字面值常量的本质是char型数组，且末尾多一个字符'\0'。

如果两个字符串字面值的位置紧邻，且之间仅有空格、缩进、换行符分隔，则这两个紧邻的字符串常量是一个整体，这种写法常用来解决输出比较长而换行写的情况。如：

```cpp
std::cout<<"22222222222222222222"
            "2222222222222222222222222222"<<std::endl;
```
##### 2.1.3.2.1 转译序列
有两类字符程序员无法**直接使用**：
1. 不可打印的字符，比如退格等控制字符，因为它们没有可视的图符
2. 特殊含义的字符，比如：单引号、双引号、问好、反斜线，

在以上情况下，要想正常使用则必须使用反斜线进行转译，才能当做正常的字符使用。

```
换行符   \n
反斜线   \\
回车符   \r
退格符   \b
问号     \?
报警     \a
双引号   \'
单引号   \"
```
同时，也可以借助转译符号，通过 转译符号+数字 的方式直接使用字符集中的字符。有以下两种使用发：

1. \x后面紧跟一个或者多个十六进制数组，以表示一个或者多个字符

2. \后面跟1个、2个、3个八进制数字，以表示一个字符；注意，如果反斜杠后面的八进制数超过三个，转义符号只能转译前三个。

比如：

```
\115   字母M，3个八进制数
\40    空格，2个八进制数
\0     空字符，1个八进制数
\x4d   字符M，1个十六进制数
\x4dO\115    表示字符串MOM
\1154       表示字符串 M4
\0x1231231231231231  就表示
```
#### 2.1.3.3 显式声明字面量常量的类型
如果不想让编译器自动推断字面量常量的类型，可以显示声明字面量常量的类型信息，比如：

```
L'a'   声明是wchar_t类型的字符型常量
u8"hi!"   声明是utf8编码的字符串字面值
42ULL    声明是unsigned long long，long一定要使用L大写来表示以避免小写的L和数字1混淆
1E-3F    声明是float
3.14159L    声明是long double
```

#### 2.1.3.4 布尔值的字面值和空指针字面值
```cpp
bool a=true;
a=false;
a=nullptr;
```

## 2.2 变量
变量提供一个具名的、可供程序操作的存储空间。cpp中每个变量都有其数据类型，数据类型决定着：

1、变量所占空间的大小和布局方式

2、变量所占用的空间可能存储的值的范围

3、变量能参与的运算

cpp中，变量和对象的概念一般是可以互换使用的。

### 2.2.1 变量定义
变量的定义的基本形式：类型说明符+1个或者多个变量名组成列表+分号。列表中每个的变量名的类型都是由类型说明符指定，定义的同事还可以顺带为变量赋初始值（也就是，进行显式初始化）。

比如：

```cpp
int sum=0,
    value,
    units_sold=0;//三个   P38


```



